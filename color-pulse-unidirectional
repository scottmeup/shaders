// configurable unidirectional color pulse

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float brightnessIntensity; // calculated brightness of a position using either just pulse, or combined with background if colorTrailingCutoffIncludesBackground is set to true
    float colorBackgroundBlue; // background color - values range from 0.0 to 1.0
    float colorBackgroundGreen; // background color - values range from 0.0 to 1.0
    float colorBackgroundRed; // background color - values range from 0.0 to 1.0
    bool colorCombineTrailingBackground; // combine traling color with background color. overwrites background color if false
    float colorPulseBlue; // pulse color - values range from 0.0 to 1.0
    float colorPulseGreen; // pulse color - values range from 0.0 to 1.0
    float colorPulseRed; // pulse color - values range from 0.0 to 1.0
    float colorTrailingBlue; // color following decay - values range from 0.0 to 1.0
    float colorTrailingCutoff; // use trailing color when other brightness is below this
    bool colorTrailingCutoffIncludesBackground; // check background + pulse intensity. only checks pulse brightness if false.
    float colorTrailingGreen; // color following decay - values range from 0.0 to 1.0
    float colorTrailingRed; // color following decay - values range from 0.0 to 1.0
    bool combineBackgroundWithTrailing; // add the chosen background color to the trailing color if this is enabled
    float decaySpeedBase;  // linear factor affecting speed that brightness drops off with time / distance from pulse head. higher = quicker dropoff, darker sooner.
    float decaySpeedExponent;  // exponential factor affecting speed that brightness drops off with time / distance from pulse head. higher = quicker dropoff, darker sooner.
    float distanceLED; // distance of the head of the pulse from the current LED element, measured in LEDs
    float distancePercent; // distance of the head of the pulse from the current pixel, measured in percent. values range from 0.0 to 1.0
    float distancePixel; // distance  of the head of the pulse from the current pixel, measured in pixels.
    bool horizontal; // move horizontally. if false will move vertically instead.
    float indexLED;  // position of individual LED from 0 to N. N is set by numLEDs.
    float indexPixel; // position of individual display element from 0 to N where N is the number of pixels in the relevant dimension.
    float indexPercent; // position in display area as a percent. values range from 0.0 to 1.0
    float numLEDs; // Number of LEDs in the display from one end to the other - must be set by user
    float numPixels; // Size of display in pixels in the direction of movement
    bool outputSteppedDisplay; // Breaks the output up by the number of LEDs specified in numLEDs if true. Uses the resolution of the display area if false.
    float pauseDuration; // time to wait between end of one pulse and start of the next
    float pulseDuration; // time taken for pulse to move from beginning to end of display
    float pulseHeadSizeLED; // width in individual LED elements for the initial no-decayed pulse
    float pulseHeadSizePercent; // width of the pulse head's no-decay zone as a percentage of the display area
    float pulseHeadSizePixel; // width in pixels for the initial no-decayed pulse
    float pulsePositionLED; // current progress of pulse through totalCycle. Measured in LED elements, based on pulsePositionPercent & numLEDs.
    float pulsePositionPercent; // current progress of pulse through totalCycle:Measured as a percentage. Value is between 0.0 and 1.0
    float pulsePositionPixel; // current progress of pulse through totalCycle. Measured in pixels.
    float pulseMinimumBrightness; // stop decaying pulse brightness below this level
    float ratioCycleToPulse; // Ratio of total amount of time between cycle starts to the time for a pulse to traverse the display 
    vec2 resolution; // resolution of display device, provided by the software
    bool reverse; // flip direction of movement. defaults to Left->Right, Top->Bottom
    float speed; // speed setting: higher speed = faster movement
    float time; // clock, used to calculate cycle progress
    float totalCycleStepsLED; // size of a cycle from one beginning to the next. calculated as total time divided by time per LED transition.
    float totalCycleStepsPixel; // size of a cycle from one beginning to the next. calculated as total time divided by time per pixel transition.
    float totalCycleStepsPercent; // size of an entire cycle in percent, based on the actual display area being 100%.
    float totalCycleTime; // time between one pulse beginning and the next one starting
    vec3 vectorColorBackground; //  combined color vector for the background
    vec3 vectorColorOutput; // combined background + pulse color vector
    vec3 vectorColorPulse; // combined color vector for the moving pulse
    vec3 vectorColorTrailing; // combined color vector for space after the decay trail
    float widthLEDInPixels; // ratio of LED elements to pixels
    float widthLEDInPercent; // ratio of LED elements to % of total display width

    // colorPulse defines the head of the moving pulse
    // colorTrailing is a color applied after the brightness decays to a specified cutoff level
    // colorBackground is a base color applied to the pulse and optionally to the trailing section following the pulse cutoff
    // combineBackgroundWithTrailing optionally adds the background color to the section trailing the cutoff
    // reverse, horizontal affect direction of movement
    // pulseTime affects the time for the bright region to move across the display
    // pauseTime adds a delay between the end of one pulse and the beginning of the next
    // pulseMinimumBrightness sets a level of brightness not to decay below
    // decaySpeedBase and decaySpeedExponent affect the rate that brightness drops off. higher decaySpeed = shorter pulse appearance. decaySpeedBase is a linear factor, decaySpeedExponent is exponential.
    // speed is a global speed modifier
    // pulseHeadSizeLED adds a region where there is no decay in brightness at the start of the pulse. Each unit will be the width of 1 addressable position if numLEDs is set correctly

    
    // Configuration section
    // See above for details
    colorBackgroundBlue = 0.0;
    colorBackgroundGreen = 0.0;
    colorBackgroundRed = 0.0;
    colorPulseBlue = 0.0;
    colorPulseGreen = 1.0;
    colorPulseRed = 0.0;
    colorTrailingBlue = 0.0;
    colorTrailingCutoff = 0.0;
    colorTrailingCutoffIncludesBackground = false;
    colorTrailingGreen = 0.0;
    colorTrailingRed = 0.0;
    combineBackgroundWithTrailing = true;
    decaySpeedBase = 1.0;
    decaySpeedExponent = 1.0;
    horizontal = true;
    numLEDs = 6.0;
    outputSteppedDisplay = false;
    pauseDuration = 6.0;
    pulseMinimumBrightness = 0.0;
    pulseDuration = 6.0;    
    pulseHeadSizeLED = 1.0;
    reverse = false;
    speed = 1.0;


    // Get the resolution from Shadertoy
    resolution = iResolution.xy;
    
    
    // Adjust the display parameters to suit the direction & number of LEDs & pixels
    if (horizontal){
        indexPixel = fragCoord.x;
        numPixels = resolution.x;
    }
    else{
        indexPixel = fragCoord.y;
        numPixels = resolution.y;      
    }
    indexPercent = indexPixel / numPixels;
    widthLEDInPixels = numPixels / numLEDs;
    widthLEDInPercent = 1.0 / numLEDs;
    speed = speed * (numPixels / pulseDuration);
/*
    indexLED = floor(indexPixel * numLEDs);
*/
    
    // Get the current time from shadertoy
    if(reverse){
         time = iTime * speed * -1.0;
    }
    else{
        time = iTime * speed;
    }
     
    
    vec3 ones3d = vec3(1.0, 1.0, 1.0);
    
    totalCycleTime = pulseDuration + pauseDuration;
    ratioCycleToPulse = totalCycleTime / pulseDuration;
    totalCycleStepsPercent = ratioCycleToPulse + (pulseHeadSizeLED * widthLEDInPercent);
    totalCycleStepsPixel = (numPixels * totalCycleStepsPercent);
    totalCycleStepsLED = (numLEDs * ratioCycleToPulse) + pulseHeadSizeLED;
    
    pulsePositionPixel = mod(time, totalCycleStepsPixel);
    pulsePositionPercent = pulsePositionPixel / totalCycleStepsPixel;
    pulsePositionLED = floor(pulsePositionPercent * numLEDs);

    pulseHeadSizePercent = pulseHeadSizeLED * widthLEDInPercent;
    pulseHeadSizePixel = pulseHeadSizeLED * widthLEDInPixels;
    
    distancePixel = mod((pulsePositionPixel - indexPixel), totalCycleStepsPixel);
    distancePercent = distancePixel / totalCycleStepsPixel;
    
    vectorColorBackground.x = colorBackgroundRed;
    vectorColorBackground.y = colorBackgroundGreen;
    vectorColorBackground.z = colorBackgroundBlue;
    vectorColorPulse.x = colorPulseRed;
    vectorColorPulse.y = colorPulseGreen;
    vectorColorPulse.z = colorPulseBlue;
    vectorColorTrailing.x = colorTrailingRed;
    vectorColorTrailing.y = colorTrailingGreen;
    vectorColorTrailing.z = colorTrailingBlue;



/*
    // Set display output mode: pixel or LED
    float index;
    if (outputSteppedDisplay){
        index = indexLED;
    }
    else{
        index = indexPixel;;
    }
*/

    // generate output for reversed motion direction
    if(reverse){
        distancePixel = (indexPixel - pulsePositionPixel);
        // account for head of pulse wrapping around
        if (distancePixel < 0.0){
            distancePixel = distancePixel + totalCycleStepsPixel;
        }

        // Head of pulse
        if (distancePixel <= pulseHeadSizePixel) {
            if (distancePixel >= 0.0){
                vectorColorPulse = vec3(colorPulseRed, colorPulseGreen, colorPulseBlue);
            }

        }
        else {
            // Trail following head of pulse - reversed direction
            vectorColorPulse = vectorColorPulse * max(exp(((distancePixel * -1.0) + pulseHeadSizePixel) * decaySpeedBase), pulseMinimumBrightness);
        }
    }
    // generate output for default motion direction
    else{
/*
        if (pulsePositionPixel > indexPixel){
            distancePixel = (pulsePositionPixel - indexPixel);
            vectorColorBackground = vec3(1.0, 0.0, 0.0);
            // # RED #
        }

        // account for head of pulse wrapping around
        else {
            distancePixel = (pulsePositionPixel - indexPixel + totalCycleStepsPixel);
            vectorColorBackground = vec3(0.0, 0.0, 1.0);
            // # BLUE #
        }
*/

        // Head of pulse. Set to the originally specified pulse color.
        if (distancePercent < (pulseHeadSizePercent)) {
            //vectorColorPulse = vectorColorPulse + vec3(0.0, 0.5, 0.0);
            //vectorColorPulse = vectorColorPulse + vec3(1.0, 1.0, 1.0);
            vectorColorPulse = vec3(colorPulseRed, colorPulseGreen, colorPulseBlue);
        }

        // Decay after head of pulse - normal direction
        else {
            // to-do: check the calcluations on this line
            //vectorColorPulse = vectorColorPulse * max(exp(((distancePixel)+pulseHeadSizePixel) * decaySpeedBase), pulseMinimumBrightness);
            //float decay = ((distancePixel-pulseHeadSizePercent) * decaySpeedBase);
            float decay = min(((1.0-distancePercent)+pulseHeadSizePercent), 1.0) * decaySpeedBase;
            vectorColorPulse = vectorColorPulse * decay;
            //vectorColorPulse = vectorColorPulse - vec3(decay, decay, decay);
            //vectorColorPulse = vectorColorPulse - ((distancePercent-pulseHeadSizePercent) * decaySpeedBase * vec3(0.0, 1.0, 0.0));
            //vectorColorPulse = vec3(1.0, 0.0, 1.0);
            //vectorColorBackground = vec3(1.0, 0.0, 1.0);
            // # WHITE #
        }
    }
    
    
    // calculate brightness intensity using the dot product of the color vectors and an all-ones vector
    // combine background & pulse vector intensities if that option is selected
    if (colorTrailingCutoffIncludesBackground){
        vec3 vectorColorCombinedIntensity = vec3(vectorColorPulse.x + vectorColorBackground.x, vectorColorPulse.y + vectorColorBackground.y, vectorColorPulse.z + vectorColorBackground.z);
        vectorColorCombinedIntensity.x = min(1.0, vectorColorCombinedIntensity.x);
        vectorColorCombinedIntensity.y = min(1.0, vectorColorCombinedIntensity.y);
        vectorColorCombinedIntensity.z = min(1.0, vectorColorCombinedIntensity.z);
        brightnessIntensity = dot(vectorColorCombinedIntensity, ones3d);
    }
    else{
       brightnessIntensity = dot(vectorColorPulse, ones3d);
    }
    
    if (brightnessIntensity < colorTrailingCutoff){
        vectorColorPulse = vectorColorTrailing;
        if (combineBackgroundWithTrailing){
            vectorColorPulse = vectorColorPulse + vectorColorBackground;
        }
    }
    
    
    // Set output
    vectorColorOutput = vectorColorPulse + vectorColorBackground;
    fragColor = vec4(vectorColorOutput.x, vectorColorOutput.y, vectorColorOutput.z, 1.0);
}
