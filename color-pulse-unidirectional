// configurable unidirectional color pulse

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float brightnessIntensity; // calculated brightness of a position using either just pulse, or combined with background if colorTrailingCutoffIncludesBackground is set to true
    float colorBackgroundBlue; // background color - values range from 0.0 to 1.0
    float colorBackgroundGreen; // background color - values range from 0.0 to 1.0
    float colorBackgroundRed; // background color - values range from 0.0 to 1.0
    bool colorCombineTrailingBackground; // combine traling color with background color. overwrites background color if false
    float colorPulseBlue; // pulse color - values range from 0.0 to 1.0
    float colorPulseGreen; // pulse color - values range from 0.0 to 1.0
    float colorPulseRed; // pulse color - values range from 0.0 to 1.0
    float colorTrailingBlue; // color following decay - values range from 0.0 to 1.0
    float colorTrailingCutoff; // use trailing color when other brightness is below this
    bool colorTrailingCutoffIncludesBackground; // check background + pulse intensity. only checks pulse brightness if false.
    float colorTrailingGreen; // color following decay - values range from 0.0 to 1.0
    float colorTrailingRed; // color following decay - values range from 0.0 to 1.0
    bool combineBackgroundWithTrailing; // add the chosen background color to the trailing color if this is enabled
    float cyclePosition; // current progress through totalCycle
    float decaySpeedBase;  // linear factor affecting speed that brightness drops off with time / distance from pulse head. higher = quicker dropoff, darker sooner.
    float decaySpeedExponent;  // exponential factor affecting speed that brightness drops off with time / distance from pulse head. higher = quicker dropoff, darker sooner.
    float distLeft; // distance per LED from head of pulse on LHS / start
    bool horizontal; // move horizontally. if false will move vertically instead.
    float ledIndex;  // position of individual LED
    float numLEDs; // Change this value to the number of LEDs in the display
    float pauseDuration; // time to wait between end of one pulse and start of the next
    float pulseDuration; // time taken for pulse to move from beginning to end of display
    float pulseHeadSize; // width in individual LED elements for the initial no-decayed pulse
    float pulsePositionLeft; // progress of pulse head from LHS / start
    float pulseMinimumBrightness; // stop decaying pulse brightness below this level
    vec2 resolution; // resolution of display device, provided by the software
    bool reverse; // flip direction of movement. defaults to Left->Right, Top->Bottom
    float speed; // speed setting: higher speed = faster movement
    float time; // clock, used to calculate cycle progress
    float totalCycleSteps; // total "width" of a cycle based on equally timed display state changes
    float totalCycleTime; // time between one pulse beginning and the next one starting
    vec3 vectorColorBackground; //  combined color vector for the background
    vec3 vectorColorOutput; // combined background + pulse color vector
    vec3 vectorColorPulse; // combined color vector for the moving pulse
    vec3 vectorColorTrailing; // combnied color vector for space after the decay trail

    // colorPulse defines the head of the moving pulse
    // colorTrailing is a color applied after the brightness decays to a specified cutoff level
    // colorBackground is a base color applied to the pulse and optionally to the trailing section following the pulse cutoff
    // combineBackgroundWithTrailing optionally adds the background color to the section trailing the cutoff
    // reverse, horizontal affect direction of movement
    // pulseTime affects the time for the bright region to move across the display
    // pauseTime adds a delay between the end of one pulse and the beginning of the next
    // pulseMinimumBrightness sets a level of brightness not to decay below
    // decaySpeedBase and decaySpeedExponent affect the rate that brightness drops off. higher decaySpeed = shorter pulse appearance. decaySpeedBase is a linear factor, decaySpeedExponent is exponential.
    // speed is a global speed modifier
    // pulseHeadSize adds a region where there is no decay in brightness at the start of the pulse. Each unit will be the width of 1 addressable position if numLEDs is set correctly

    
    // Configuration section
    // See above for details
    colorBackgroundBlue = 0.0;
    colorBackgroundGreen = 0.0;
    colorBackgroundRed = 0.0;
    colorPulseBlue = 0.0;
    colorPulseGreen = 1.0;
    colorPulseRed = 0.0;
    colorTrailingBlue = 0.125;
    colorTrailingCutoff = 0.0;
    colorTrailingCutoffIncludesBackground = false;
    colorTrailingGreen = 0.0;
    colorTrailingRed = 0.0;
    combineBackgroundWithTrailing = true;
    decaySpeedBase = 0.25;
    decaySpeedExponent = 1.0;
    horizontal = false;
    numLEDs = 6.0;
    pauseDuration = 4.0;
    pulseMinimumBrightness = 0.0;
    pulseDuration = 2.0;    
    pulseHeadSize = 1.0;
    reverse = false;
    speed = 1.0;

    // Get the resolution from Shadertoy
    resolution = iResolution.xy;
    
    // Adjust the display to suit the number of LEDs
    if (horizontal){
        ledIndex = fragCoord.x / resolution.x * numLEDs;
    }
    else{
        ledIndex = fragCoord.y / resolution.y * numLEDs;
    }
    
    // Get the current time from shadertoy
    if(reverse){
         time = iTime * speed * -1.0;
    }
    else{
        time = iTime * speed;
    }
    
    
    vec3 ones3d = vec3(1.0, 1.0, 1.0);
    totalCycleTime = pulseDuration + pauseDuration;
    cyclePosition = mod(time, totalCycleTime) / pulseDuration;
    totalCycleSteps = numLEDs * (totalCycleTime / pulseDuration);
    pulsePositionLeft = cyclePosition * numLEDs;
    vectorColorBackground.x = colorBackgroundRed;
    vectorColorBackground.y = colorBackgroundGreen;
    vectorColorBackground.z = colorBackgroundBlue;
    vectorColorPulse.x = colorPulseRed;
    vectorColorPulse.y = colorPulseGreen;
    vectorColorPulse.z = colorPulseBlue;
    vectorColorTrailing.x = colorTrailingRed;
    vectorColorTrailing.y = colorTrailingGreen;
    vectorColorTrailing.z = colorTrailingBlue;

    // reversed motion direction
    if(reverse){
        distLeft = ledIndex - (pulsePositionLeft);
        // account for head of pulse wrapping around
        if (distLeft <0.0){
            distLeft = distLeft + totalCycleSteps;
        }
        // Head of pulse
        if (distLeft <= pulseHeadSize) {
            if (distLeft >= 0.0){
                vectorColorPulse = vec3(colorPulseRed, colorPulseGreen, colorPulseBlue);
            }

        }
        else {
            // Trail following head of pulse - reversed direction
            vectorColorPulse = vectorColorPulse * max(exp(((distLeft * -1.0) + pulseHeadSize) * decaySpeedExponent), pulseMinimumBrightness);
        }
    }
    // default motion direction
    else{
        if (pulsePositionLeft >= ledIndex){
            distLeft = (ledIndex - pulsePositionLeft);
        }
        // account for head of pulse wrapping around
        else {
            distLeft = (ledIndex - (pulsePositionLeft + totalCycleSteps));
        }

        // Head of pulse
        if (distLeft > (-1.0 * pulseHeadSize)) {
            vectorColorPulse = vectorColorPulse = vec3(colorPulseRed, colorPulseGreen, colorPulseBlue);  
        }
        // Trail after head of pulse - normal direction
        else {
            // to-do: check the calcluations on this line
            vectorColorPulse = vectorColorPulse * max(exp(((distLeft)+pulseHeadSize) * decaySpeedBase), pulseMinimumBrightness);
        }
    }
    
    // calculate brightness intensity using the dot product of the color vectors and an all-ones vector
    // combine background & pulse vector intensities if that option is selected
    if (colorTrailingCutoffIncludesBackground){
        vec3 vectorColorCombinedIntensity = vec3(vectorColorPulse.x + vectorColorBackground.x, vectorColorPulse.y + vectorColorBackground.y, vectorColorPulse.z + vectorColorBackground.z);
        vectorColorCombinedIntensity.x = min(1.0, vectorColorCombinedIntensity.x);
        vectorColorCombinedIntensity.y = min(1.0, vectorColorCombinedIntensity.y);
        vectorColorCombinedIntensity.z = min(1.0, vectorColorCombinedIntensity.z);
        brightnessIntensity = dot(vectorColorCombinedIntensity, ones3d);
        
    }
    else{
       brightnessIntensity = dot(vectorColorPulse, ones3d);
    }
    
    if (brightnessIntensity < colorTrailingCutoff){
        vectorColorPulse = vectorColorTrailing;
        if (combineBackgroundWithTrailing){
            vectorColorPulse = vectorColorPulse + vectorColorBackground;
        }
    }
    
    // Set output
    vectorColorOutput = vectorColorPulse + vectorColorBackground;
    fragColor = vec4(vectorColorOutput.x, vectorColorOutput.y, vectorColorOutput.z, 1.0);
}
