// configurable unidirectional color pulse with decay trail
// starts at left / lowest element and moves toward the right
// works with shadertoy + openrgb

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 resolution;
    vec3 color;
    bool reverse; // flip direction of movement. defaults to Left->Right, Top->Bottom
    bool horizontal; // move horizontally. if false will move vertically instead.
    float pulsePositionLeft; // progress of pulse head from LHS / start
    float ledIndex;  // position of individual LED
    float time; // clock, used to calculate cycle progress
    float decayFactor;  // speed that brightness drops off with time / distance from pulse head. higher = quicker dropoff / darker.
    float pulseDuration; // time taken for pulse to move from beginning to end of display
    float pauseDuration; // time to wait between pulses
    float totalCycleTime; // time between one pulse beginning and the next one starting
    float cyclePosition; // current progress through totalCycle
    float totalSteps; // total "width" of a cycle based on equally timed display state changes
    float distLeft; // distance per LED from head of pulse on LHS / start
    float brightnessRed = 0.0; // color values range from 0.0 to 1.0
    float brightnessGreen = 1.0;
    float brightnessBlue = 0.0;
    const float numLEDs = 12.0; // Change this value to the number of LEDs in the display
    const float speed = 1.5; // speed setting: higher speed = faster movement
    const float pulseHeadSize = 1.0; // width in elements of initial pulse, should be non-negative;
    
    

    // Get the current time from shadertoy
    time = iTime;
    
    reverse = false;
    horizontal = true;
    decayFactor = 0.5;
    time = time * speed;
    
    // Get the resolution from Shadertoy
    resolution = iResolution.xy;
    
    // Adjust the display to suit the number of LEDs
    if (horizontal){
        ledIndex = fragCoord.x / resolution.x * numLEDs;
    }
    else{
        ledIndex = fragCoord.y / resolution.y * numLEDs;
        reverse = !reverse;
    }
       
    if (reverse){
    time = time * -1.0;
    }
    
    pulseDuration = 2.0;    
    pauseDuration = 3.0;
    totalCycleTime = pulseDuration + pauseDuration;
    cyclePosition = mod(time, totalCycleTime) / pulseDuration;
    totalSteps = numLEDs * (totalCycleTime / pulseDuration);
    pulsePositionLeft = cyclePosition * numLEDs;
    color.x = brightnessRed;
    color.y = brightnessGreen;
    color.z = brightnessBlue;
 
        
    if(reverse){
        distLeft = ledIndex - (pulsePositionLeft);
        if (distLeft <0.0){
            distLeft = distLeft + totalSteps;
        }
        // Head of pulse
        if (distLeft <= pulseHeadSize) {
            if (distLeft >= 0.0){
                color = color * 1.0;
            }

        }
        else {
            // Decay trail after head of pulse
            color = color * exp(((distLeft * -1.0) + pulseHeadSize) * decayFactor);
        }
    }
    else{
        if (pulsePositionLeft >= ledIndex){
            distLeft = (ledIndex - pulsePositionLeft);
        }
        else {
            distLeft = (ledIndex - (pulsePositionLeft + totalSteps));
        }

        // Head of pulse
        if (distLeft > (-1.0 * pulseHeadSize)) {
            color = color * 1.0;  
        }
        // Trail after head of pulse
        else {
            color = color * exp((distLeft+pulseHeadSize) * decayFactor);
        }
    }

       
    // Set output
    fragColor = vec4(color.x, color.y, color.z, 1.0);
}
