#version 460 
//Comment out the above line to use with shader toy

// configurable color pulses


// - Additional Features to consider
// - - Inverse brightness mode
// - - Set fixed or rotated color at specific LED position
//
// To-do
// - Check timing of first LED in fade_and_decay_first_and_last_led_only
// - Look into brightness as a function of RGB, consider re-working brightness calculation
// - - Especially for blending pulse head to fade-in
// - Write better variable names for get_decay_and_fade_offsets()
// - Implement head offset & head buffer column settings
// - Find out why 6th (element 5) column (purple to blue) sometimes blips full blue before transition in hsluv debug.
// - - Fade in value? Yes. Somehow related to fade-in.
// - - - Check brightness algorithm


// Begin User Config Globals Section
//
//
const int size_of_display_in_columns = 11;    // how many parallel pulses to run
const bool direction_movement_horizontal = false;
const bool direction_movement_reversed = false;
const float duration_of_pause = 20.0;   //  Time between the front of the pulse leaving the screen and the next pulse appearing 
const float duration_of_pulse = 10.0;    // Time taken for the front of the pulse to run across the display
const float speed_global_modifier = 1.0;    // When set to 1.0, cycle will play at 1 second per unit of duration
//
//
// End User Config Section


#ifdef GLSLVIEWER
#define u_tex0 iChannel0;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
uniform sampler2D u_tex0;
vec2 iResolution;   // viewport resolution (in pixels)
float iTime;        // shader playback time (in seconds)
vec4 iMouse;        // mouse pixel coords (xy), click state (zw)
out vec4 FragColor;         // Final color output
void mainImage(out vec4 fragColor, in vec2 fragCoord);
#endif

#define PI 3.14159265358979323846
#define TWO_PI 2.0*PI

const vec3 ones3d = vec3(1.0, 1.0, 1.0);
const vec3 zeros3d = vec3(0.0, 0.0, 0.0);
const float one_third = (1.0 / 3.0);
const float two_thirds = (2.0 / 3.0);
const vec3 red = vec3(1.0, 0.0, 0.0);
const vec3 orange = vec3(1.0, 0.75, 0.0);
const vec3 yellow = vec3(1.0, 1.0, 0.0 );
const vec3 green = vec3(0.0, 1.0, 0.0);
const vec3 cyan = vec3(0.0, 1.0, 1.0);
const vec3 blue = vec3(0.0, 0.0, 1.0);
const vec3 violet = vec3(0.5, 0.0, 1.0);
const vec3 magenta = vec3(1.0, 0.0, 1.0);
const vec3 white = ones3d;
const vec3 black = zeros3d;
const float dark = 0.5;
const float epsilon_0_to_100 = 1e-5;
const float pi = PI;
const float two_pi = TWO_PI;


const int hsluv_max_lightness_lut_size = 360;
const float hsluv_max_lightness_lut[hsluv_max_lightness_lut_size] = float[](
    54.400000, 54.300000, 54.200000, 54.100000, 54.000000, 53.900000, 53.800000, 53.700000, 53.600000, 53.500000,
    53.400000, 53.300000, 53.200000, 54.100000, 55.000000, 56.000000, 56.900000, 57.800000, 58.600000, 59.400000,
    60.200000, 61.000000, 61.700000, 62.400000, 63.100000, 63.800000, 64.500000, 65.100000, 65.700000, 66.400000,
    67.000000, 67.600000, 68.100000, 68.700000, 69.300000, 69.800000, 70.400000, 70.900000, 71.500000, 72.000000,
    72.500000, 73.000000, 73.500000, 74.100000, 74.600000, 75.100000, 75.600000, 76.100000, 76.500000, 77.000000,
    77.500000, 78.000000, 78.500000, 79.000000, 79.500000, 79.900000, 80.400000, 80.900000, 81.400000, 81.900000,
    82.400000, 82.900000, 83.400000, 83.900000, 84.400000, 84.900000, 85.400000, 85.900000, 86.400000, 86.900000,
    87.500000, 88.000000, 88.500000, 89.100000, 89.600000, 90.200000, 90.800000, 91.400000, 92.000000, 92.600000,
    93.200000, 93.800000, 94.500000, 95.100000, 95.800000, 96.500000, 97.100000, 96.900000, 96.600000, 96.400000,
    96.200000, 96.000000, 95.800000, 95.600000, 95.400000, 95.200000, 95.000000, 94.800000, 94.600000, 94.400000,
    94.200000, 94.000000, 93.700000, 93.500000, 93.300000, 93.100000, 92.900000, 92.700000, 92.500000, 92.300000,
    92.000000, 91.800000, 91.600000, 91.400000, 91.200000, 90.900000, 90.700000, 90.500000, 90.200000, 90.000000,
    89.700000, 89.500000, 89.200000, 89.000000, 88.700000, 88.400000, 88.200000, 87.900000, 87.700000, 87.800000,
    87.900000, 88.000000, 88.100000, 88.200000, 88.200000, 88.300000, 88.400000, 88.500000, 88.500000, 88.600000,
    88.700000, 88.700000, 88.800000, 88.800000, 88.900000, 89.000000, 89.000000, 89.100000, 89.100000, 89.200000,
    89.200000, 89.300000, 89.300000, 89.400000, 89.400000, 89.500000, 89.500000, 89.600000, 89.600000, 89.700000,
    89.700000, 89.800000, 89.800000, 89.800000, 89.900000, 89.900000, 90.000000, 90.000000, 90.100000, 90.100000,
    90.100000, 90.200000, 90.200000, 90.300000, 90.300000, 90.400000, 90.400000, 90.400000, 90.500000, 90.500000,
    90.600000, 90.600000, 90.600000, 90.700000, 90.700000, 90.800000, 90.800000, 90.900000, 90.900000, 90.900000,
    91.000000, 91.000000, 91.100000, 90.700000, 90.300000, 89.900000, 89.400000, 89.000000, 88.600000, 88.200000,
    87.800000, 87.300000, 86.900000, 86.500000, 86.100000, 85.700000, 85.300000, 84.900000, 84.400000, 84.000000,
    83.600000, 83.200000, 82.800000, 82.300000, 81.900000, 81.500000, 81.100000, 80.600000, 80.200000, 79.800000,
    79.300000, 78.900000, 78.400000, 77.900000, 77.500000, 77.000000, 76.500000, 76.000000, 75.500000, 75.000000,
    74.500000, 74.000000, 73.400000, 72.900000, 72.300000, 71.800000, 71.200000, 70.600000, 70.000000, 69.300000,
    68.700000, 68.000000, 67.300000, 66.600000, 65.900000, 65.100000, 64.300000, 63.500000, 62.600000, 61.700000,
    60.700000, 59.800000, 58.700000, 57.600000, 56.500000, 55.200000, 53.900000, 52.500000, 51.000000, 49.400000,
    47.700000, 45.700000, 43.600000, 41.300000, 38.600000, 38.100000, 38.100000, 38.200000, 38.200000, 38.200000,
    38.200000, 38.200000, 38.500000, 39.300000, 40.200000, 41.000000, 41.700000, 42.500000, 43.200000, 43.900000,
    44.600000, 45.300000, 45.900000, 46.600000, 47.200000, 47.800000, 48.400000, 49.000000, 49.600000, 50.200000,
    50.800000, 51.400000, 51.900000, 52.500000, 53.000000, 53.600000, 54.100000, 54.700000, 55.200000, 55.700000,
    56.300000, 56.800000, 57.300000, 57.800000, 58.400000, 58.900000, 59.400000, 59.900000, 60.300000, 60.100000,
    59.900000, 59.800000, 59.600000, 59.400000, 59.300000, 59.100000, 59.000000, 58.900000, 58.700000, 58.600000,
    58.500000, 58.300000, 58.200000, 58.100000, 58.000000, 57.900000, 57.700000, 57.600000, 57.500000, 57.400000,
    57.300000, 57.200000, 57.100000, 57.000000, 56.900000, 56.800000, 56.700000, 56.600000, 56.500000, 56.400000,
    56.300000, 56.200000, 56.100000, 56.000000, 55.900000, 55.800000, 55.700000, 55.600000, 55.500000, 55.400000,
    55.400000, 55.300000, 55.200000, 55.100000, 55.000000, 54.900000, 54.800000, 54.700000, 54.600000, 54.500000);


struct Pulse_settings 
{
    vec3 rgb_pulse;    // (R, G, B) Color for pulse
    vec3 rgb_pause;     // (R, G, B) Color for negative space: non-pulse area
    vec3 rgb_fade_in;    // (R, G, B) Color applied to fade-in in front of pulse
    vec3 rgb_background;    // (R, G, B) Color applied uniformly on top of others
    float size_of_display_in_leds;    // Set to the number of LEDs in your display in order to align other settings properly   
    float size_pulse_head_in_leds;    // Non-decay area at the start of the pulse. Will run at brightness specified in rgb_pulse for the length of the number of LEDs specified
    float decay_speed_exponential;    // 0.0 for no exponential decay. Higher number = faster decay, shorter / darker pulse.
    float decay_speed_linear;    // 0.0 for no linear decay. Higher number = faster decay, shorter / darker pulse.
    float fade_in_speed_exponential;    // 0.0 for no exponential fade-in. Generate a fade-in on the LED before the pulse. Higher number = faster = shorter.
    float fade_in_speed_linear;    // 0.0 for no linear fade-in. Generate a fade-in on the LED before the pulse. Higher number = faster = shorter.
    float color_brightness_cutoff;    // switch to non-pulse, "pause" section of cycle coloring below this brightness.
    float color_pulse_minimum_brightness_percent;    // Minimum brightness of pulse as a percent. Will not decay below this level.
    float head_offset_in_leds;    // Amount of space to shift the head. +ive = backwards.
    float head_buffer_leds;    // Amount of space to separate decay & fade in from the head section, measured in LEDs. Default is 0.0
    float head_buffer_alignment_in_leds;    // Amount of space to shift the buffer between the decay & fade in sections from the head, measured in LEDs. +ive = shift to the rear. Default is 0.0
    bool color_brightness_cutoff_includes_background_brightness;    // Consider background coloring or not when determining the brightness of a pixel for cutoff to pause coloring.
    bool color_combine_background_with_pause_color;    // Overlay the background color on top of the "pause" / negative space color.
    bool color_combine_pulse_head_with_fade_in;    // Smooth transition between fade-in and pulse head
    bool display_discrete_led_output;   // Simulate LED display based on size_of_display_in_leds.
    bool fade_and_decay_first_and_last_led_only;    // Only apply fade-in to the first LED before the pulse appears, and to the last LED after the pulse leaves. Requires display_discrete_led_output and either fade_in or decay.
    bool input_is_rgb;   // If true, treat input colors as RGB. If false, treat colors as HSLuv
};



// Begin User Config Pulse / Example Settings Section
//
//
void Initialize_pulse_settings_array(inout Pulse_settings pulse[size_of_display_in_columns]){
    // Use order of variables listed above in "struct Pulse_settings"
    //                                                                                                              LEDs in |Pulse |Decay|Decay|Fade |Fade | Bright | Min    | head   | head   | buffer |Cufoff| BG + | Head+| LED   | 1st+ 
    //                              Pulse-color  |  Pause-color         | Fade-in color       | Background-color  | Display | Head | Exp | Lin | Exp | Lin | Cutoff | Bright | offset | buffer | offset |BG    | Pause| Fade | Output| last
                                                                                                                                                                                                                                    

    pulse[0]  = Pulse_settings(vec3(1.0, 0.0, 0.0 ), vec3(0.0, 0.0, 0.05), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 5.0,      1.0,   3.0,  0.0,  0.0,   0.0,  0.0,   0.0,     0.0,     0.0,     0.0,    false,  true, false,  true,   false,    true );     // Device 1
    pulse[1]  = Pulse_settings(vec3(1.0, 0.75, 0.0), vec3(0.0, 0.0, 0.05), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 3.0,      1.0,   3.0,  0.0,  0.0,   0.0,  0.0,   0.0,     0.0,     0.0,     0.0,    false,  true, false,  true,   false,    true );     // Device 2
    pulse[2]  = Pulse_settings(vec3(1.0, 1.0, 0.0 ), vec3(0.0, 0.0, 0.1 ), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 3.0,      2.0,   3.0,  0.0,  0.0,   0.0,  0.0,   0.0,     0.0,     0.0,     0.0,    false,  true, false,  true,   false,    true );     // Device 3
    pulse[3]  = Pulse_settings(vec3(0.0, 1.0, 0.0 ), vec3(0.0, 0.0, 0.0 ), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 14.0,     1.0,   3.0,  0.0,  14.0,  0.0,  0.0,   0.0,     0.0,     0.0,     0.0,    false,  true, false,  true,   false,    true );     // Device 4
    pulse[4]  = Pulse_settings(vec3(0.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), 8.0,      1.0,   3.0,  0.0,  0.0,   0.0,  0.0,   0.0,     0.0,     0.0,     0.0,    false,  true, false,  true,   false,    true );     // Device 5     //#TO DO# Look at this case - Is head coloring / lighting correct?
    pulse[5]  = Pulse_settings(vec3(0.0, 1.0, 1.0 ), vec3(0.0, 0.0, 0.5 ), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 8.0,      1.0,   3.0,  0.0,  0.0,   0.0,  0.05,  0.0,     0.0,     0.0,     0.0,    false,  true, false,  true,   false,    true );     // Device 6     //#TO DO# Look at this case - head seems to be delayed by one step compared to other columns
    pulse[6]  = Pulse_settings(vec3(0.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(0.5, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 8.0,      1.0,   3.0,  0.0,  16.0,  0.0,  0.0,   0.0,     0.0,     0.0,     0.0,    false,  true, true,   true,   false,    true );     // Device 7
//    pulse[7]  = Pulse_settings(vec3(1.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 3.0,      1.0,   3.0,  0.0,  1.0,   3.0,  0.025,     0.0,   0.0, 0.0,     0.0,    false,  true, false,  true,   true,     true );     // Device 8
//    pulse[8]  = Pulse_settings(vec3(0.5, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(0.5, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 4.0,      0.0,   0.0,  1.0,  0.0,   1.0,  0.025,     0.0,   0.0, 0.0,     0.0,    false,  true, false,  true,   false,    true );     // Device 9
    pulse[7]  = Pulse_settings(vec3(1.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 4.0,      1.0,   3.0,  0.0,  1.0,   3.0,  0.0,   0.0,     0.0,     0.0,     0.0,    false,  true, false,  true,   true,     true );     // Device 8
    pulse[8]  = Pulse_settings(vec3(1.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 4.0,      1.0,   3.0,  0.0,  1.0,   3.0,  0.0,   0.0,     0.0,     0.0,     0.0,    false,  true, false,  false,  false,    true );     // Device 9
    pulse[9]  = Pulse_settings(vec3(1.0, 1.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 4.0,      0.0,   9.0,  0.0,  9.0,   0.0,  0.0,   0.0,     0.0,     0.0,     0.0,    false,  true, false,  false,  false,    true );     // Device 10
    pulse[10] = Pulse_settings(vec3(1.0, 1.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 4.0,      0.0,   0.0,  1.5,  0.0,   0.0,  0.0,   0.3,     0.0,     0.0,     0.0,    false,  true, false,  false,  false,    true );     // Device 11

/*
    // Test cases for fade-in
    pulse[0]  = Pulse_settings(vec3(1.0, 0.0, 0.0 ), vec3(0.0, 0.0, 0.05), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 5.0,      1.0,   0.0,  0.0,  1.0,   0.0,  0.0,   0.0,     false,  true, false,  true,   false);     // Device 1
    pulse[1]  = Pulse_settings(vec3(1.0, 0.75, 0.0), vec3(0.0, 0.0, 0.05), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 3.0,      1.0,   0.0,  0.0,  0.0,   1.0,  0.0,   0.0,     false,  true, false,  true,   false);     // Device 2
    pulse[2]  = Pulse_settings(vec3(1.0, 1.0, 0.0 ), vec3(0.0, 0.0, 0.1 ), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 3.0,      2.0,   0.0,  0.0,  1.0,   1.0,  0.0,   0.0,     false,  true, false,  true,   false);     // Device 3
    pulse[3]  = Pulse_settings(vec3(0.0, 1.0, 0.0 ), vec3(0.0, 0.0, 0.0 ), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 14.0,     1.0,   0.0,  0.0,  0.0,   0.0,  0.0,   0.0,     false,  true, false,  true,   false);     // Device 4
    pulse[4]  = Pulse_settings(vec3(0.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), 8.0,      1.0,   0.0,  0.0,  2.0,   0.0,  0.0,   0.0,     false,  true, false,  true,   false);     // Device 5
    pulse[5]  = Pulse_settings(vec3(0.0, 1.0, 1.0 ), vec3(0.0, 0.0, 0.5 ), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 8.0,      1.0,   0.0,  0.0,  0.0,   2.0,  0.1,   0.0,     false,  true, false,  true,   false);     // Device 6
    pulse[6]  = Pulse_settings(vec3(0.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(0.5, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 8.0,      1.0,   0.0,  0.0,  2.0,   2.0,  0.0,   0.0,     false,  true, true,   true,   false);     // Device 7
    pulse[7]  = Pulse_settings(vec3(1.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 2.0,      1.0,   0.0,  0.0,  0.0,   0.0,  0.0,   0.0,     false,  true, false,  true,   true );     // Device 8
    pulse[8]  = Pulse_settings(vec3(1.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 2.0,      1.0,   0.0,  0.0,  3.0,   0.0,  0.0,   0.0,     false,  true, false,  false,  false );     // Device 9
    pulse[9]  = Pulse_settings(vec3(1.0, 1.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 4.0,      0.0,   0.0,  0.0,  0.0,   3.0,  0.0,   0.0,     false,  true, false,  false,  false );    // Device 10
    pulse[10] = Pulse_settings(vec3(1.0, 1.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 4.0,      0.0,   0.0,  0.0,  0.0,   0.0,  0.0,   0.3,     false,  true, false,  false,  false );    // Device 11
*/

/*

    // Test cases for decay pulse
    pulse[0]  = Pulse_settings(vec3(1.0, 0.0, 0.0 ), vec3(0.0, 0.0, 0.05), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 5.0,      1.0,   1.0,  0.0,  0.0,   0.0,  0.0,   0.0,     false,  true, false,  true,   false);     // Device 1
    pulse[1]  = Pulse_settings(vec3(1.0, 0.75, 0.0), vec3(0.0, 0.0, 0.05), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 3.0,      1.0,   0.0,  1.0,  0.0,   0.0,  0.0,   0.0,     false,  true, false,  true,   false);     // Device 2
    pulse[2]  = Pulse_settings(vec3(1.0, 1.0, 0.0 ), vec3(0.0, 0.0, 0.1 ), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 3.0,      2.0,   1.0,  1.0,  0.0,   0.0,  0.0,   0.0,     false,  true, false,  true,   false);     // Device 3
    pulse[3]  = Pulse_settings(vec3(0.0, 1.0, 0.0 ), vec3(0.0, 0.0, 0.0 ), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 14.0,     1.0,   0.0,  0.0,  0.0,   0.0,  0.0,   0.0,     false,  true, false,  true,   false);     // Device 4
    pulse[4]  = Pulse_settings(vec3(0.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), 8.0,      1.0,   2.0,  0.0,  0.0,   0.0,  0.0,   0.0,     false,  true, false,  true,   false);     // Device 5
    pulse[5]  = Pulse_settings(vec3(0.0, 1.0, 1.0 ), vec3(0.0, 0.0, 0.5 ), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 8.0,      1.0,   0.0,  2.0,  0.0,   0.0,  0.1,   0.0,     false,  true, false,  true,   false);     // Device 6
    pulse[6]  = Pulse_settings(vec3(0.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(0.5, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 8.0,      1.0,   2.0,  2.0,  0.0,   0.0,  0.0,   0.0,     false,  true, true,   true,   false);     // Device 7
    pulse[7]  = Pulse_settings(vec3(1.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 2.0,      1.0,   0.0,  0.0,  0.0,   0.0,  0.0,   0.0,     false,  true, false,  true,   true );     // Device 8
    pulse[8]  = Pulse_settings(vec3(1.0, 0.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 2.0,      1.0,   3.0,  0.0,  0.0,   0.0,  0.0,   0.0,     false,  true, false,  false,  false );     // Device 9
    pulse[9]  = Pulse_settings(vec3(1.0, 1.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 4.0,      0.0,   0.0,  3.0,  0.0,   0.0,  0.0,   0.0,     false,  true, false,  false,  false );    // Device 10
    pulse[10] = Pulse_settings(vec3(1.0, 1.0, 1.0 ), vec3(0.0, 0.0, 0.0 ), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 4.0,      0.0,   3.0,  3.0,  0.0,   0.0,  0.0,   0.3,     false,  true, false,  false,  false );    // Device 11

*/

/*
    // Test cases for decay pulse, fade-in, both, and none
    pulse[0]  = Pulse_settings(red, white, green, black, 10.0,      1.00,   2.0,  0.0,  0.0,  0.0,  0.00,   0.0,     false,  true, false,  true,   false);     // Device 1 - pulse linear               - no fade-in
    pulse[1]  = Pulse_settings(red, white, green, black, 10.0,      1.00,   0.0,  2.0,  0.0,  0.0,  0.00,   0.0,     false,  true, false,  true,   false);     // Device 2 - pulse exponential          - no fade-in
    pulse[2]  = Pulse_settings(red, white, green, black, 10.0,      1.00,   2.0,  2.0,  0.0,  0.0,  0.00,   0.0,     false,  true, false,  true,   false);     // Device 3 - pulse linear + exponential - no fade-in
    pulse[3]  = Pulse_settings(red, white, green, black, 10.0,      1.00,   0.0,  0.0,  2.0,  0.0,  0.00,   0.0,     false,  true, false,  true,   false);     // Device 4 - no pulse                   - fade-in linear
    pulse[4]  = Pulse_settings(red, white, green, black, 10.0,      1.00,   0.0,  0.0,  0.0,  2.0,  0.00,   0.0,     false,  true, false,  true,   false);     // Device 5 - no pulse                   - fade-in exponential
    pulse[5]  = Pulse_settings(red, white, green, black, 10.0,      1.00,   0.0,  0.0,  2.0,  2.0,  0.00,   0.0,     false,  true, false,  true,   false);     // Device 6 - no pulse                   - fade in linear + exponential
    pulse[6]  = Pulse_settings(red, white, green, black, 10.0,      1.00,   0.0,  0.0,  0.0,  0.0,  0.00,   0.0,     false,  true, false,  true,   false);     // Device 7 - no pulse                   - no fade-in
    pulse[7]  = Pulse_settings(red, white, green, black, 10.0,      1.00,   2.0,  2.0,  2.0,  2.0,  0.00,   0.0,     false,  true, false,  true,   false);     // Device 8 - pulse linear + exponential - fade-in linear + exponential
    pulse[8]  = Pulse_settings(red, white, green, black, 10.0,      1.00,   1.0,  0.0,  1.0,  0.0,  0.00,   0.0,     false,  true, false,  false,   false);    // Device 9
    pulse[9]  = Pulse_settings(red, white, green, black, 10.0,      1.00,   0.0,  1.0,  0.0,  1.0,  0.00,   0.0,     false,  true, false,  false,   false);    // Device 10
    pulse[10] = Pulse_settings(red, white, green, black, 10.0,      1.00,   1.0,  1.0,  1.0,  0.0,  0.00,   0.3,     false,  true, false,  false,   false);    // Device 11

*/
    /*

    // Alternative way to initialize a pulse:
    // Does the same thing as the examples above.
    pulse[0].rgb_pulse = vec3(0.0, 1.0, 0.0);
    pulse[0].rgb_pause = vec3(0.0, 0.0, 0.05);
    pulse[0].rgb_fade_in = vec3(0.0, 0.0, 1.0);
    pulse[0].rgb_background = vec3(0.0, 0.0, 0.0);
    pulse[0].size_of_display_in_leds = 8.0; 
    pulse[0].size_pulse_head_in_leds = 1.0;   
    pulse[0].decay_speed_exponential = 3.0;  
    pulse[0].decay_speed_linear = 0.0;   
    pulse[0].fade_in_speed_exponential = 16.0;  
    pulse[0].fade_in_speed_linear = 0.0;   
    pulse[0].color_brightness_cutoff = 0.025;  
    pulse[0].color_pulse_minimum_brightness_percent = 0.0;  
    pulse[0].color_brightness_cutoff_includes_background_brightness = false;
    pulse[0].color_combine_background_with_pause_color = false;   
    pulse[0].color_combine_pulse_head_with_fade_in = true;   
    pulse[0].display_discrete_led_output = true;
    pulse[0].fade_and_decay_first_and_last_led_only = false;
    
    */

}
//
//
// End User Config Section


vec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {
    return (line1y - line2y) / (line2x - line1x);
}

vec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {
    return sqrt(pointx*pointx + pointy*pointy);
}

vec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {
    vec3 len = y / (sin(theta) - x * cos(theta));
    if (len.r < 0.0) {len.r=1000.0;}
    if (len.g < 0.0) {len.g=1000.0;}
    if (len.b < 0.0) {len.b=1000.0;}
    return len;
}

float hsluv_maxSafeChromaForL(float L){
    mat3 m2 = mat3(
         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,
        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,
        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  
    );
    float sub0 = L + 16.0;
    float sub1 = sub0 * sub0 * sub0 * .000000641;
    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;

    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;
    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;
    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;

    vec3 bounds0x = top1 / bottom;
    vec3 bounds0y = top2 / bottom;

    vec3 bounds1x =              top1 / (bottom+126452.0);
    vec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);

    vec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );
    vec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );

    vec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );
    vec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );

    return  min(lengths0.r,
            min(lengths1.r,
            min(lengths0.g,
            min(lengths1.g,
            min(lengths0.b,
                lengths1.b)))));
}

float hsluv_maxChromaForLH(float L, float H) {

    float hrad = radians(H);

    mat3 m2 = mat3(
         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,
        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,
        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  
    );
    float sub1 = pow(L + 16.0, 3.0) / 1560896.0;
    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;

    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;
    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;
    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;

    vec3 bound0x = top1 / bottom;
    vec3 bound0y = top2 / bottom;

    vec3 bound1x =              top1 / (bottom+126452.0);
    vec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);

    vec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );
    vec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );

    return  min(lengths0.r,
            min(lengths1.r,
            min(lengths0.g,
            min(lengths1.g,
            min(lengths0.b,
                lengths1.b)))));
}

float hsluv_fromLinear(float c) {
    return c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;
}
vec3 hsluv_fromLinear(vec3 c) {
    return vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );
}

float hsluv_toLinear(float c) {
    return c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;
}

vec3 hsluv_toLinear(vec3 c) {
    return vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );
}

float hsluv_yToL(float Y){
    return Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;
}

float hsluv_lToY(float L) {
    return L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);
}

vec3 xyzToRgb(vec3 tuple) {
    const mat3 m = mat3( 
        3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,
       -0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,
        0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );
    
    return hsluv_fromLinear(tuple*m);
}

vec3 rgbToXyz(vec3 tuple) {
    const mat3 m = mat3(
        0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,
        0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,
        0.019330818715591851, 0.11919477979462599, 0.95053215224966058 
    );
    return hsluv_toLinear(tuple) * m;
}

vec3 xyzToLuv(vec3 tuple){
    float X = tuple.x;
    float Y = tuple.y;
    float Z = tuple.z;

    float L = hsluv_yToL(Y);
    
    float div = 1./dot(tuple,vec3(1,15,3)); 

    return vec3(
        1.,
        (52. * (X*div) - 2.57179),
        (117.* (Y*div) - 6.08816)
    ) * L;
}


vec3 luvToXyz(vec3 tuple) {
    float L = tuple.x;

    float U = tuple.y / (13.0 * L) + 0.19783000664283681;
    float V = tuple.z / (13.0 * L) + 0.468319994938791;

    float Y = hsluv_lToY(L);
    float X = 2.25 * U * Y / V;
    float Z = (3./V - 5.)*Y - (X/3.);

    return vec3(X, Y, Z);
}

vec3 luvToLch(vec3 tuple) {
    float L = tuple.x;
    float U = tuple.y;
    float V = tuple.z;

    float C = length(tuple.yz);
    float H = degrees(atan(V,U));
    if (H < 0.0) {
        H = 360.0 + H;
    }
    
    return vec3(L, C, H);
}

vec3 lchToLuv(vec3 tuple) {
    float hrad = radians(tuple.b);
    return vec3(
        tuple.r,
        cos(hrad) * tuple.g,
        sin(hrad) * tuple.g
    );
}

vec3 hsluvToLch(vec3 tuple) {
    tuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;
    return tuple.bgr;
}

vec3 lchToHsluv(vec3 tuple) {
    tuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;
    return tuple.bgr;
}

vec3 hpluvToLch(vec3 tuple) {
    tuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;
    return tuple.bgr;
}

vec3 lchToHpluv(vec3 tuple) {
    tuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;
    return tuple.bgr;
}

vec3 lchToRgb(vec3 tuple) {
    return xyzToRgb(luvToXyz(lchToLuv(tuple)));
}

vec3 rgbToLch(vec3 tuple) {
    return luvToLch(xyzToLuv(rgbToXyz(tuple)));
}

vec3 hsluvToRgb(vec3 tuple) {
    return lchToRgb(hsluvToLch(tuple));
}

vec3 rgbToHsluv(vec3 tuple) {
    if(tuple==(vec3(0.0, 0.0, 0.0))){
        return tuple;
    }
    else{
        return lchToHsluv(rgbToLch(tuple));
    }
}

vec3 hpluvToRgb(vec3 tuple) {
    return lchToRgb(hpluvToLch(tuple));
}

vec3 rgbToHpluv(vec3 tuple) {
    return lchToHpluv(rgbToLch(tuple));
}

vec3 luvToRgb(vec3 tuple){
    return xyzToRgb(luvToXyz(tuple));
}

// allow vec4's
vec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}
vec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}
vec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}
vec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}
vec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}
vec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}
vec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}
vec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}
vec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}
vec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}
vec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}
vec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}
vec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}
vec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}
vec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}
vec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}
vec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}
// allow 3 floats
vec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}
vec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}
vec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}
vec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}
vec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}
vec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}
vec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}
vec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}
vec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}
vec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}
vec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}
vec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}
vec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}
vec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}
vec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}
vec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}
vec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}
// allow 4 floats
vec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}
vec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}
vec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}
vec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}
vec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}
vec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}
vec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}
vec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}
vec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}
vec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}
vec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}
vec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}
vec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}
vec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}
vec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}
vec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}
vec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}


float ratio_normalized(float a, float b){
    if((a >= 0.0) && (b >= 0.0)){
    
        float ratio = ((b - a) + epsilon_0_to_100) / (b + a + (2*epsilon_0_to_100));
        ratio *= 0.5;
        ratio += 0.5;
        return ratio;

    }
    else{
        return sin(3.0 * iTime);
    }
}

vec3 srgb_to_linear_rgb(vec3 c) {
    return mix(
        c / 12.92,
        pow((c + 0.055) / 1.055, vec3(2.4)),
        step(0.04045, c)
    );
}

vec3 linear_rgb_to_srgb(vec3 c) {
    return mix(
        c * 12.92,
        1.055 * pow(c, vec3(1.0 / 2.4)) - 0.055,
        step(0.0031308, c)
    );
}

vec3 clamp_hsluv(vec3 hsluv){
    hsluv[0] = mod(hsluv[0], 360.0);                   // hue [0-360]
    hsluv[1] = clamp(hsluv[1], 0.0, 100.0);     // saturation [0-100]
    hsluv[2] = clamp(hsluv[2], 0.0, 100.0);      // lightness [0-100]
    return hsluv;
}

float normalize_trig_function(float input_value){
    input_value += 1.0;
    input_value /= 2.0;
    return input_value;
}


// Interpolate HSLuv
// Interpolation function for hue, handling circular wraparound
float interpolate_hue(float h1, float h2, float t) {
    float delta = mod(h2, 360.0) - mod(h1, 360.0);

    // If calculated difference in angle is more than 1/2 a circle 
    if (abs(delta) > 180.0) {
        if (delta > 0.0)
            delta -= 360.0;
        else
            delta += 360.0;
    }

    //float result = h1 + t * delta;  // original
    float result = mix(h1, h2, t);  // new test

    // Wrap around [0, 360)
    result = mod(result, 360.0);
    //if (result < 0.0) result += 360.0;
    //if (result >= 360.0) result -= 360.0;

    // some debug
    if(t>1.0 || t<0.0){
        result = sin(3.0 * iTime)*360.0;
    }

    return result;
}


float get_max_safe_lightness(vec3 hsluv_color){
    // Handle unsaturated colors
    if(hsluv_color[1] < 10.0){
        return 100.0;
    }
    else{
        float hue_angle = hsluv_color[0];
        int idx_above = int(mod(ceil(hue_angle), 360.0));
        int idx_below = int(mod(floor(hue_angle), 360.0));
        return min(hsluv_max_lightness_lut[idx_below], hsluv_max_lightness_lut[idx_above]);
    }
}


// Return the max lightness for a hue angle that doesn't result in diminished chroma
// Not the best - white isn't handled properly
float get_max_safe_lightness(float hue_angle) {
    int idx_above = int(mod(ceil(hue_angle), 360.0));
    int idx_below = int(mod(floor(hue_angle), 360.0));
    return min(hsluv_max_lightness_lut[idx_below], hsluv_max_lightness_lut[idx_above]);
}

vec3 scale_hsluv_lightness(vec3 color_hsluv){
    float hsluv_hue_angle = color_hsluv[0];
    float hsluv_saturation = color_hsluv[1];
    float hsluv_lightness = color_hsluv[2];
    //Apply to colors only, with a cutoff saturation defining what is a color
    if(hsluv_saturation>10.0){
        float hsluv_lightness = get_max_safe_lightness(hsluv_hue_angle);
    }
    return vec3(hsluv_hue_angle, hsluv_saturation, hsluv_lightness);
}

// Interpolate between two HSLuv colors (vec3(h, s, l))
vec3 interpolate_hsluv(vec3 hsluvA, vec3 hsluvB, float t) {
    float h = interpolate_hue(hsluvA.x, hsluvB.x, t);
    float s = mix(hsluvA.y, hsluvB.y, t);
    float l = mix(hsluvA.z, hsluvB.z, t);
    return vec3(h, s, l);
}


bool close_to(float value_variable, float value_comparison, float tolerance){
    if(value_variable > (value_comparison - (tolerance/2.0)) && (value_variable < (value_comparison + (tolerance/2.0)))){
        return true;
    }
    else{
        return false;
    }
} 


float invert_value(float value, float range){
    return range - value;
}

float restrict_float_from_0_to_1(float var){
// Return a float with value between 0.0 and 1.0
    var = min(var, 1.0);
    var = max(var, 0.0);
    return var;
}


vec3 restrict_vec3_from_0_to_1(vec3 var){
// Return a 3D vector with values between 0.0 and 1.0
    var = min(var, 1.0);
    var = max(var, 0.0);
    return var;
}

float distance_with_wrap(float position_initial, float position_final, float size_of_space){
    float delta = (position_final - position_initial);
    float distance = 0.0;
    // More than 50% of the total space between points means that the space boundary is between them
    if(abs(delta) > (size_of_space/2.0)){
        // Case: delta is positive and crosses the space boundary
        if(delta > 0.0){
            delta -= size_of_space;
        }
        // Case: delta is negative and crosses the space boundary
        else if(delta < 0.0){
            delta += size_of_space;
        }
        else{
            return 0.0;
        }
    }
    return delta;
}


vec2 get_decay_and_fade_offsets(float head_buffer_leds, float head_buffer_alignment_in_leds, float size_of_led_as_percent_of_display, float size_pulse_head_in_leds){
    // Alighment & buffer space between full-intensity section and fade-in / decay start for calculations.
    // Takes number of LEDs as inputs and returns percent of display
    //
    // head_buffer_leds: amount of space to extend / retract the fade & decay areas
    // head_buffer_alignment_in_leds: shift the fade & decay areas forward or backward by this amount of LEDs
    // size_of_led_as_percent_of_display: number of LED elements in the display
    // size_pulse_head_in_leds: size of full intensity area as a multiple of LEDs
    //
    // head_buffer_leds = 0.0, head_buffer_alignment_in_leds = 0.5 : full illumination to exactly 1 LED element at a time and aligns LEDs to index of pulse
    // 
    // Probably best managed as part of Pulse_settings or with additional logic: doesn't always play nice with continuous display mode
    vec2 offset;
    //
    // Adjust default behavior to align start of calculation at the pulse index, trailing the pulse.
    // offset.x = trailing edge, offset.y = leading edge
    //
    offset.x = ( (head_buffer_leds) / 2.0 ) + head_buffer_alignment_in_leds + size_pulse_head_in_leds;
    offset.y = ( (head_buffer_leds) / 2.0 ) - head_buffer_alignment_in_leds;
    offset = offset * size_of_led_as_percent_of_display;
    return offset;
}


bool define_led_element_at_offset_from_pulse_index(float offset_from_pulse_in_leds, float size_of_defined_element_in_leds, float size_of_display_in_leds, float distance_of_current_location_in_front_of_pulse_as_percent_of_display, float distance_of_current_location_behind_pulse_as_percent_of_display){
    // # Clean this up #
    
    float size_of_single_led_as_percent_of_display = 1.0 / size_of_display_in_leds;
    float size_of_defined_element_as_percent_of_display = size_of_single_led_as_percent_of_display * size_of_defined_element_in_leds;
    
    // Center element on pulse index
    // + moves backward
    // - moves forward
    float size_forward =  ((-offset_from_pulse_in_leds)                                     * size_of_single_led_as_percent_of_display);
    float size_backward = (  offset_from_pulse_in_leds  + size_of_defined_element_in_leds ) * size_of_single_led_as_percent_of_display;
    
    bool element_is_defined = false;
    
    if (size_forward >= size_of_defined_element_as_percent_of_display){
        // Entire head is in front of the pulse and not touching it
        if(distance_of_current_location_in_front_of_pulse_as_percent_of_display < (size_forward - size_of_defined_element_as_percent_of_display) ){
            element_is_defined = false;
        }
        else if(distance_of_current_location_in_front_of_pulse_as_percent_of_display <= size_forward){
            element_is_defined = true;
        }
        else{
            element_is_defined = false;
        }
    }
    else if (size_backward >= size_of_defined_element_as_percent_of_display){
        // Entire head is behind the pulse and not touching it
        if(distance_of_current_location_behind_pulse_as_percent_of_display < (size_backward - size_of_defined_element_as_percent_of_display) ){
            element_is_defined = false;
        }
        else if(distance_of_current_location_behind_pulse_as_percent_of_display <= size_backward){
            element_is_defined = true;
        }
        else{
            element_is_defined = false;
        }
    }
    //Head spans the pulse index if neither of the above two options applies
    else if(distance_of_current_location_in_front_of_pulse_as_percent_of_display <= size_forward ){
        element_is_defined = true;
    }
    else if(distance_of_current_location_behind_pulse_as_percent_of_display <= size_backward ){
        element_is_defined = true;
    }
    
    return element_is_defined;
}


float get_led_offset_as_percent_of_display(float offset_in_leds, float size_of_led_as_percent_of_display){
    // Return the display distance for a given number of LED elements as a percentage of the display size
    float offset = offset_in_leds * size_of_led_as_percent_of_display;
    return offset;
}

vec2 get_distance_of_current_location_from_pulse_as_percent_of_display(float pulse_location_as_percent_of_display, float current_location_on_y_axis_of_display_as_percent_of_display, float size_of_cycle_as_percent_of_display){
    // Get the the distance of the current location behind (vec2.x) and in front of (vec2.y) the pulse index
    
    float distance_of_current_location_in_front_of_pulse_as_percent_of_display;
    float distance_of_current_location_behind_pulse_as_percent_of_display;
    if(direction_movement_reversed){
        distance_of_current_location_in_front_of_pulse_as_percent_of_display = mod( (pulse_location_as_percent_of_display - current_location_on_y_axis_of_display_as_percent_of_display), size_of_cycle_as_percent_of_display);
        distance_of_current_location_behind_pulse_as_percent_of_display = invert_value(distance_of_current_location_in_front_of_pulse_as_percent_of_display, size_of_cycle_as_percent_of_display);
    }
    else{
        distance_of_current_location_behind_pulse_as_percent_of_display = mod( (pulse_location_as_percent_of_display - current_location_on_y_axis_of_display_as_percent_of_display), size_of_cycle_as_percent_of_display);
        distance_of_current_location_in_front_of_pulse_as_percent_of_display = invert_value(distance_of_current_location_behind_pulse_as_percent_of_display, size_of_cycle_as_percent_of_display);
    }
    return vec2(distance_of_current_location_behind_pulse_as_percent_of_display, distance_of_current_location_in_front_of_pulse_as_percent_of_display);
}

vec2 get_display_location_as_percent_of_display_size(vec2 fragCoord){
    // Generate (x,y) coordinates of display location adjusted for horizontal / vertical direction of movement
    float size_display_width_in_pixels;
    float size_display_height_in_pixels;
    float position_current_pixel_x;
    float position_current_pixel_y;
    if (direction_movement_horizontal){
        size_display_width_in_pixels = iResolution.y;
        size_display_height_in_pixels = iResolution.x;
        position_current_pixel_x = fragCoord.y;
        position_current_pixel_y = fragCoord.x;   
    }else{
        size_display_width_in_pixels = iResolution.x;
        size_display_height_in_pixels = iResolution.y;
        position_current_pixel_x = fragCoord.x;
        position_current_pixel_y = fragCoord.y;   
    }
    vec2 display_location_as_percent_of_display = vec2(position_current_pixel_x/size_display_width_in_pixels, position_current_pixel_y/size_display_height_in_pixels);
    return display_location_as_percent_of_display;
}

vec3[4] adjust_lightness_hsluv(vec3[4] color_element){
    int lightest_color = -1;
    float max_lightness = -1.0;

    // Calculate lightest element
    for(int i=0; i<4; i++){
        if(color_element[i][2] > max_lightness){
            max_lightness = color_element[i][2];
            lightest_color = i;
        }
    }

    // Scale lightness of other elements
    float highest_safe_lightness = get_max_safe_lightness(color_element[lightest_color]);
    float ratio_hsluv_lightness_reduction = ( highest_safe_lightness / color_element[lightest_color][2] );
    for(int i=0; i<4; i++){
        if(i==lightest_color){
            color_element[i] = scale_hsluv_lightness(color_element[i]);
        }
        else{
            // Choose the lowest of either the current lightness for the color, or the safest lightness for the color
            color_element[i][2] = min(get_max_safe_lightness(color_element[i]), color_element[i][2]);
            // Reduce by the same % as the lightest element was reduced
            // Play around with this and see if it's better with or without it
            color_element[i][2] *= ratio_hsluv_lightness_reduction;
        }
    }
    return color_element;
}

float get_pulse_location_as_percent_of_display(){
    float duration_of_cycle = duration_of_pause + duration_of_pulse;
    float size_of_cycle_as_percent_of_screen = duration_of_cycle / duration_of_pulse;
    float speed_of_movement_per_second_as_percent_of_display = 1.0 / duration_of_pulse;

    
    // Move beginning of pulse across the screen and calculate distance from each screen location
    float speed_reverse_modifier = 1.0;
    if(direction_movement_reversed){
        speed_reverse_modifier = -1.0;
    }
    float time = mod(iTime*speed_global_modifier*speed_reverse_modifier, duration_of_cycle);
    float location_of_pulse_as_percent_of_display = speed_of_movement_per_second_as_percent_of_display * time;
    return location_of_pulse_as_percent_of_display;
}


/*
float get_distance_of_current_location_behind_pulse_as_percent(float current_location_on_y_axis_of_display_as_percent_of_display, float position_of_pulse_as_percent_of_display, float size_of_cycle_as_percent_of_screen, bool direction_movement_reversed){
    // Set up distance from end of pulse head based on normal or reverse direction of movement
    vec3 display_output_vector;
    float distance_of_current_location_behind_pulse_as_percent;
    if(direction_movement_reversed){
        distance_of_current_location_behind_pulse_as_percent = mod((current_location_on_y_axis_of_display_as_percent_of_display - position_of_pulse_as_percent_of_display), size_of_cycle_as_percent_of_screen); 
    }
    else{
        distance_of_current_location_behind_pulse_as_percent = mod((position_of_pulse_as_percent_of_display - current_location_on_y_axis_of_display_as_percent_of_display), size_of_cycle_as_percent_of_screen);  
    }
    return distance_of_current_location_behind_pulse_as_percent;
}


float get_size_of_LED_as_percent_of_display(float number_of_leds_in_display){
    float size_of_LED = 1.0/(number_of_leds_in_display);
    return size_of_LED;
}
*/

/*
float get_distance_of_current_location_from_pulse_as_percent_of_display(float pulse_location_as_percent_of_display, float current_location_on_y_axis_of_display_as_percent_of_display, float size_of_cycle_as_percent_of_display, bool behind_pulse){
    // For the purposes of this function, behind_pulse refers to the screen coordinate of interest being a lower index with regard to the display device:
    // ie. to the left of, or below the pulse location.
    float direction_modifier = 1.0;
    if(!behind_pulse){
        direction_modifier = -1.0;
    }
    float distance_of_current_location_behind_pulse_as_percent_of_display = mod( ( ( pulse_location_as_percent_of_display * direction_modifier) - (current_location_on_y_axis_of_display_as_percent_of_display * direction_modifier)), size_of_cycle_as_percent_of_display);
    return distance_of_current_location_behind_pulse_as_percent_of_display;
}

*/

float discrete_LED_output(float distance_of_current_location_behind_start_of_led_as_percent_of_display, float distance_of_current_location_behind_pulse_as_percent, float size_of_led_as_percent_of_display, float size_of_cycle_as_percent_of_screen, bool ){
// Align distance to the end of the LED segment that the pulse index is inside

    // Keeps illuminated LED betweeen 0 and 1 LED width ahead of the pulse index with regard to the direction of movement
    // Illuminated LED will always be at a higher screen position otherwise
    // Update: something changed, now this isn't needed?
    if(direction_movement_reversed){
        //distance_of_current_location_behind_start_of_led_as_percent_of_display -= size_of_led_as_percent_of_display;
    }
    
    // Add current distance behind pulse to current distance behind start of LED and wrap around at the size of the whole cycle
    distance_of_current_location_behind_pulse_as_percent = distance_of_current_location_behind_pulse_as_percent + distance_of_current_location_behind_start_of_led_as_percent_of_display;
    distance_of_current_location_behind_pulse_as_percent = mod(distance_of_current_location_behind_pulse_as_percent, size_of_cycle_as_percent_of_screen);
    return distance_of_current_location_behind_pulse_as_percent;
}


/*
vec3 generate_fade_in(float current_location_on_y_axis_of_display_as_percent_of_display, float pulse_location_as_percent_of_display, float size_of_cycle_as_percent_of_screen, Pulse_settings pulse){
    // Generate fade-in:
    // Calculate distance of current screen position in front of pulse
    bool flag_generate_fade_in_exponential = (pulse.fade_in_speed_exponential > 0.0);
    bool flag_generate_fade_in_linear = (pulse.fade_in_speed_linear > 0.0); 
    float fade_in_linear = 1.0;
    float fade_in_exponential = 1.0;
    float size_of_led_as_percent_of_display = get_size_of_LED_as_percent_of_display(pulse.size_of_display_in_leds);
    float distance_of_current_location_in_front_of_pulse_as_percent = mod( (size_of_cycle_as_percent_of_screen - pulse_location_as_percent_of_display + current_location_on_y_axis_of_display_as_percent_of_display), size_of_cycle_as_percent_of_screen);    
    float distance_of_current_location_in_front_of_pulse_in_leds = ceil(distance_of_current_location_in_front_of_pulse_as_percent/size_of_led_as_percent_of_display);
    /*
    if(fade_and_decay_first_and_last_led_only && (position_current_led_in_display == 0.0)){
        // Delay the timing of fade-in generation if fade_and_decay_first_and_last_led_only is set
        //distance_of_current_location_in_front_of_pulse_as_percent += (1.0 * size_of_led_as_percent_of_display);
        //return vec3(0.25, 0.25, 0.25);
    }
    */
    /*
    if( distance_of_current_location_in_front_of_pulse_in_leds < 1.0 ){
        // Do nothing if current location is less than 1 LED in front of the pulse as measured in number of discrete LEDs rounded up.
        // It shouldn't be possible for this branch to execute if things are working properly.
        return vec3(1.0, 1.0, 1.0);
    }
    else{
        float distance_of_current_location_in_front_of_pulse_adjusted_for_direction = distance_of_current_location_in_front_of_pulse_as_percent;
        if(pulse.display_discrete_led_output && (pulse.size_pulse_head_in_leds <= 0.0)){
            // Shift calculated distance for intensity one LED toward the back of the pulse if discrete LED output is used and pulse has no head
            // I think it looks better without this option enabled
            if(debug_fade_in_position){
                distance_of_current_location_in_front_of_pulse_as_percent -= size_of_led_as_percent_of_display;
            }
        }
        // Generate fade-in if current location is more than 1 LED in front of the pulse;
        if (flag_generate_fade_in_linear){
            fade_in_linear = 1.0 - (distance_of_current_location_in_front_of_pulse_as_percent * pulse.fade_in_speed_linear);
        }
        if(flag_generate_fade_in_exponential){
            fade_in_exponential = exp((-distance_of_current_location_in_front_of_pulse_as_percent) * pulse.fade_in_speed_exponential);
        }
    }
}
*/


float generate_pulse_decay(float distance_of_current_location_behind_pulse_as_percent_of_display, bool behind_pulse, float pulse_location_as_percent_of_display, float size_of_cycle_as_percent_of_display, float offset_from_pulse_index, Pulse_settings pulse){
    // Generate decay pulse

    // Positive offsets move the beginning of calculations behind the pulse
    // Negative offsets move the beginning of calculations in front of the pulse 
    // mod(distance) is better left for debug - it creates a gap between the head and the decay section
    float distance_plus_offset_behind_pulse_as_percent_of_display = (distance_of_current_location_behind_pulse_as_percent_of_display - offset_from_pulse_index);
    //distance_plus_offset_behind_pulse_as_percent_of_display = mod(distance_plus_offset_behind_pulse_as_percent_of_display, size_of_cycle_as_percent_of_display);

    float decay_speed_exponential; 
    float decay_speed_linear;
    
    
    if(behind_pulse){
        decay_speed_exponential = pulse.decay_speed_exponential;
        decay_speed_linear = pulse.decay_speed_linear;
    }
    else{              // #BUG# setting this code mixes fade-in with decay pulse, behind the pulse where the decay pulse should be.
        decay_speed_exponential = pulse.fade_in_speed_exponential;
        decay_speed_linear = pulse.fade_in_speed_linear;
    }
    

    float size_of_display_in_leds = pulse.size_of_display_in_leds;
    float size_pulse_head_in_leds = pulse.size_pulse_head_in_leds;
    
    bool flag_generate_decay_linear = (decay_speed_linear > 0.0);
    bool flag_generate_decay_exponential = (decay_speed_exponential > 0.0);
    
    float size_of_pulse_head_as_percent_of_display = (size_pulse_head_in_leds / size_of_display_in_leds);
    float decay_total = 0.0;    //very important to set this

    // Case: head area. separate head rendering function should handle this space.
    // Needs to be modified for fade-in, either here or in the calling section
    // Will probably need to modify this to accept different offsets
    if((distance_of_current_location_behind_pulse_as_percent_of_display <= size_of_pulse_head_as_percent_of_display) && (behind_pulse)){
        return 0.0;
    }


    float decay_linear = 1.0 - (distance_plus_offset_behind_pulse_as_percent_of_display * decay_speed_linear);
    float decay_exponential = exp(-distance_plus_offset_behind_pulse_as_percent_of_display * decay_speed_exponential);

    // Linear + exponential 
    if( flag_generate_decay_linear && flag_generate_decay_exponential ){
        decay_total = ( decay_linear * decay_exponential );
    }
    // linear only
    else if(flag_generate_decay_linear && !(flag_generate_decay_exponential)){
        decay_total = decay_linear;
    }
    // exponential only
    else if(flag_generate_decay_exponential && !(flag_generate_decay_linear)){
        decay_total = decay_exponential;
    }
    return max(decay_total, 0.0);
}

/*
float generate_head(float pulse_location_as_percent_of_display, float current_location_on_y_axis_of_display_as_percent_of_display, float distance_of_current_location_behind_pulse_as_percent_of_display, float distance_of_current_location_in_front_of_pulse_as_percent_of_display, float head_offset_as_percent_of_display, Pulse_settings pulse){
    float size_of_display_in_leds = pulse.size_of_display_in_leds;
    float size_pulse_head_in_leds = pulse.size_pulse_head_in_leds;
    float size_of_led_as_percent_of_display = (1.0 / size_of_display_in_leds);
    float size_pulse_head_as_percent_of_display = size_of_led_as_percent_of_display * size_pulse_head_in_leds;
    float head_factor = 0.0;


    // Good idea to make this it's own separate function.
    // Can definitely clean it up a bit
    //
    // Center head on pulse index
    //float size_forward = ((size_pulse_head_as_percent_of_display)/2.0) - head_offset_as_percent_of_display;
    //float size_backward = ((size_pulse_head_as_percent_of_display)/2.0) + head_offset_as_percent_of_display;
    // Align head behind pulse index
    float size_forward = head_offset_as_percent_of_display;
    float size_backward = size_pulse_head_as_percent_of_display - head_offset_as_percent_of_display;
    
    if (size_forward > size_pulse_head_as_percent_of_display){
        // Entire head is in front of the pulse and not touching it
        if(distance_of_current_location_in_front_of_pulse_as_percent_of_display < (size_forward - size_pulse_head_as_percent_of_display) ){
            head_factor = 0.0;
        }
        else if(distance_of_current_location_in_front_of_pulse_as_percent_of_display < size_forward){
            head_factor = 1.0;
        }
        else{
            head_factor = 0.0;
        }
    }
    else if (size_backward > size_pulse_head_as_percent_of_display){
        // Entire head is behind the pulse and not touching it
        if(distance_of_current_location_behind_pulse_as_percent_of_display < (size_backward + size_pulse_head_as_percent_of_display) ){
            head_factor = 0.0;
        }
        else if(distance_of_current_location_behind_pulse_as_percent_of_display < size_backward){
            head_factor = 1.0;
        }
        else{
            head_factor = 0.0;
        }
    }
    //Head spans the pulse index if neither of the above two options applies
    else if(distance_of_current_location_in_front_of_pulse_as_percent_of_display < size_forward ){
        head_factor = 1.0;
    }
    else if(distance_of_current_location_behind_pulse_as_percent_of_display < size_backward ){
        head_factor = 1.0;
    }
    
    return head_factor;
}
*/

vec3 apply_minimum_brightness(vec3 color_at_current_location, Pulse_settings pulse){
    //enforce minimum brightness setting for pulse - do not decay below this intensity
    vec3 minimum_brightness_color;
    float brightness = dot(ones3d, color_at_current_location)/3.0;
    
    if( brightness < pulse.color_pulse_minimum_brightness_percent){
        float rgb_pulse_brightness_sum = pulse.rgb_pulse.x + pulse.rgb_pulse.y + pulse.rgb_pulse.z;
        vec3 rgb_ratio = vec3((pulse.rgb_pulse.x / rgb_pulse_brightness_sum), (pulse.rgb_pulse.y / rgb_pulse_brightness_sum), (pulse.rgb_pulse.z / rgb_pulse_brightness_sum));
        minimum_brightness_color = (rgb_ratio * pulse.color_pulse_minimum_brightness_percent * 3.0);
    }
    return minimum_brightness_color;
}


float get_brightness_of_color(vec3 color){
    // Generate a value for the brightness of a given color
    // Current implementation just returns the average value of the vector
    return (dot(ones3d, color) / 3.0);
}


/*
vec3 generate_rgb_output_column(Pulse_settings pulse, vec2 screen_location_adjusted_for_alignment_as_percent_of_display, float position_of_pulse_as_percent_of_display){

    // Draw the current pulse
    vec3 display_output_vector_column;
    
    // Set up some values to manage the logic
    //float distance_of_current_location_behind_pulse_as_percent = Distance_of_current_location_behind_pulse_as_percent();
    distance_of_current_location_behind_pulse_as_percent = 0.0;
    
    float distance_of_current_location_behind_start_of_led_in_percent;

    float size_pulse_head_in_leds = pulse.size_pulse_head_in_leds;
    float size_of_display_in_leds = pulse.size_of_display_in_leds;
    float size_of_led_as_percent_of_display = ( 1.0 / size_of_display_in_leds );
    float size_of_pulse_head_as_percent_of_display = size_of_led_as_percent_of_display * size_pulse_head_in_leds;
    float ratio_of_display_size_to_pulse_tail_size = 1.0 / (1.0 - size_of_pulse_head_as_percent_of_display);
    float distance_of_pulse_from_front_of_current_led_as_percent_of_led;
    float distance_of_pulse_from_back_of_current_led_as_percent_of_led;
    bool flag_generate_fade_in_linear = (pulse.fade_in_speed_linear > 0.0);
    bool flag_generate_fade_in_exponential = (pulse.fade_in_speed_exponential > 0.0);
    bool flag_generate_fade_in = (flag_generate_fade_in_linear || flag_generate_fade_in_exponential);
    bool flag_generate_decay_linear = (pulse.decay_speed_linear > 0.0);
    bool flag_generate_decay_exponential = (pulse.decay_speed_exponential > 0.0);
    bool flag_generate_decay = (flag_generate_fade_in_linear || flag_generate_fade_in_exponential);
    bool fade_and_decay_first_and_last_led_only = false;
    // Calculate cycle size as a multiple of screen size.
    // The result should also be the duration in seconds of the whole cycle when global speed = 1.0 
    float size_of_cycle_as_percent_of_screen = ( ( duration_of_pause + duration_of_pulse ) / duration_of_pulse );
    float position_current_led_in_display = floor( screen_location_adjusted_for_alignment_as_percent_of_display.y / size_of_led_as_percent_of_display );
    
    if(direction_movement_reversed){
        // Hmm... i thought this code was already being passed a direction-adjusted position
        position_current_led_in_display = ( (pulse.size_of_display_in_leds - 1.0) - position_current_led_in_display );
    }
    


    // Set up fade_and_decay_first_and_last_led_only mod.
    // Should result in only 1 LED having any illumination at a time, fade-in at the start and / or decay at the end.
    if( pulse.fade_and_decay_first_and_last_led_only && ( flag_generate_decay || flag_generate_fade_in ) ){
        size_pulse_head_in_leds = 0.0;
        fade_and_decay_first_and_last_led_only = true;
    }


 
    
    // Combine output with fade-in vectors
    if(flag_generate_fade_in){
        float fade_in_total = fade_in_linear * fade_in_exponential;

        vec3 display_fade_in_colored_vector_column = (pulse.rgb_fade_in * fade_in_total);

        // Keep fade-in values in sensible range
        display_fade_in_colored_vector_column = max(display_fade_in_colored_vector_column, zeros3d);
        display_fade_in_colored_vector_column = min(display_fade_in_colored_vector_column, ones3d);

        if ( ( position_current_led_in_display != 0.0 ) && fade_and_decay_first_and_last_led_only){
            // fade_and_decay_first_and_last_led_only is set but this isn't the first LED in the display.
            // Do nothing.
        }
        else{
            // Otherwise, apply the fade-in
            display_output_vector_column  = display_output_vector_column + display_fade_in_colored_vector_column;

        }
    }



    
    // Keep display values in sensible range
    display_output_vector_column = max(display_output_vector_column, zeros3d);
    display_output_vector_column = min(display_output_vector_column, ones3d);

    


    // leftover from the minimum color section
    if(false){
    }
    // Apply background to pulse section
    else{
        display_output_vector_column = display_output_vector_column + pulse.rgb_background;
    }
    return display_output_vector_column;
}
*/



void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Create array with number of parallel pulses. 
    Pulse_settings[size_of_display_in_columns] pulse_array;
    // Call method to populate the array with saved settings.
    Initialize_pulse_settings_array(pulse_array);


    // Set parameters related to display calculation
    float size_of_cycle_as_percent_of_display = (duration_of_pause + duration_of_pulse) / duration_of_pulse;
    vec2 screen_location_adjusted_for_alignment_as_percent_of_display = get_display_location_as_percent_of_display_size(fragCoord);
    float current_location_on_y_axis_of_display_as_percent_of_display = screen_location_adjusted_for_alignment_as_percent_of_display.y;
    float pulse_location_as_percent_of_display = get_pulse_location_as_percent_of_display();
    vec2 distance_from_pulse = get_distance_of_current_location_from_pulse_as_percent_of_display(pulse_location_as_percent_of_display, current_location_on_y_axis_of_display_as_percent_of_display, size_of_cycle_as_percent_of_display);
    float distance_of_current_location_behind_pulse_as_percent_of_display = distance_from_pulse.x;
    float distance_of_current_location_in_front_of_pulse_as_percent_of_display = distance_from_pulse.y;
    
    
    vec3 display_output_vector;
    vec3 display_output_hsl;


    
    
    // Calculate the column index of the current screen location
    int index_current_pulse = int(floor(screen_location_adjusted_for_alignment_as_percent_of_display.x * float(size_of_display_in_columns)));
    
    
    
    // Copy some variables from the current pulse into local scope
    Pulse_settings pulse = pulse_array[index_current_pulse];
    bool color_combine_pulse_head_with_fade_in = pulse.color_combine_pulse_head_with_fade_in;
    bool color_brightness_cutoff_includes_background_brightness = pulse.color_brightness_cutoff_includes_background_brightness;
    bool display_discrete_led_output = pulse.display_discrete_led_output;
    bool input_is_rgb = pulse.input_is_rgb;
    bool fade_and_decay_first_and_last_led_only = pulse.fade_and_decay_first_and_last_led_only;
    float color_brightness_cutoff = pulse.color_brightness_cutoff;
    float color_pulse_minimum_brightness_percent = pulse.color_pulse_minimum_brightness_percent;
    float head_buffer_alignment_in_leds = pulse.head_buffer_alignment_in_leds;
    float head_buffer_leds = pulse.head_buffer_leds;
    float head_offset_in_leds = pulse.head_offset_in_leds;
    float size_of_display_in_leds = pulse.size_of_display_in_leds;
    float size_pulse_head_in_leds = pulse.size_pulse_head_in_leds;
    vec3 rgb_background = pulse.rgb_background;
    vec3 rgb_fade_in = pulse.rgb_fade_in;
    vec3 rgb_pause = pulse.rgb_pause;
    vec3 rgb_pulse = pulse.rgb_pulse;


    // Generate HSLuv color values
    vec3 hsl_background;
    vec3 hsl_pause;
    vec3 hsl_pulse;
    vec3 hsl_fade_in;

    if(input_is_rgb){
        // Convert RGB to HSLuv
        hsl_background = clamp_hsluv(rgbToHsluv(rgb_background));
        hsl_pause = clamp_hsluv(rgbToHsluv(rgb_pause));
        hsl_pulse = clamp_hsluv(rgbToHsluv(rgb_pulse));
        hsl_fade_in = clamp_hsluv(rgbToHsluv(rgb_fade_in));
    }
    else{
        hsl_background = clamp_hsluv(rgb_background);
        hsl_pause = clamp_hsluv(rgb_pause);
        hsl_pulse = clamp_hsluv(rgb_pulse);
        hsl_fade_in = clamp_hsluv(rgb_fade_in);
    }


    // Adjust HSLuv colors
    vec3[4] hsl_array;
    hsl_array[0] = hsl_pulse;
    hsl_array[1] = hsl_fade_in;
    hsl_array[2] = hsl_pause;
    hsl_array[3] = hsl_background;
    hsl_array = adjust_lightness_hsluv(hsl_array);
    hsl_pulse = hsl_array[0];
    hsl_fade_in = hsl_array[1];
    hsl_pause = hsl_array[2];
    hsl_background = hsl_array[3];
    
    // Set up some variables related to display
    float size_of_led_as_percent_of_display = (1.0 / size_of_display_in_leds);
    float size_pulse_head_as_percent_of_display = size_of_led_as_percent_of_display * size_pulse_head_in_leds;

    // Generate LED map and distance from each screen location behind the start of the LED it is a part of,
    // adjusted for the direction of movement
    float distance_of_current_location_behind_start_of_led_as_percent_of_display = mod(current_location_on_y_axis_of_display_as_percent_of_display, size_of_led_as_percent_of_display);
    if(direction_movement_reversed){
            distance_of_current_location_behind_start_of_led_as_percent_of_display = invert_value(distance_of_current_location_behind_start_of_led_as_percent_of_display, size_of_led_as_percent_of_display);
    }

    // Call discrete LED output method
    if(display_discrete_led_output){
        distance_of_current_location_behind_pulse_as_percent_of_display = discrete_LED_output(distance_of_current_location_behind_start_of_led_as_percent_of_display, distance_of_current_location_behind_pulse_as_percent_of_display, size_of_led_as_percent_of_display, size_of_cycle_as_percent_of_display, direction_movement_reversed);
    }
    distance_of_current_location_in_front_of_pulse_as_percent_of_display = invert_value(distance_of_current_location_behind_pulse_as_percent_of_display, size_of_cycle_as_percent_of_display);

   
    /*
    // Shift head as a multiple of a full LED. -ive is behind pulse, +ive is in front of pulse.
    float head_offset_in_leds = 0.0;    
    
    // Generate offsets of decay from head location
    float head_buffer_leds = 0.0; 
    float head_buffer_alignment_in_leds = 0.0;  
    */
    
    //if(!display_discrete_led_output){
        // Center head on pulse index in contiuous output mode
        //
        //head_offset_as_percent_of_display = get_led_offset_as_percent_of_display(head_offset_as_percent_of_display, size_of_led_as_percent_of_display);
        
        
    head_buffer_leds = pulse.head_buffer_leds;
    head_buffer_alignment_in_leds = pulse.head_buffer_alignment_in_leds;
        
    //}
    
    vec2 decay_and_fade_offset = get_decay_and_fade_offsets(head_buffer_leds, head_buffer_alignment_in_leds, size_of_led_as_percent_of_display, size_pulse_head_in_leds);
    


    

    
 
    // Generate head
    //float head_factor = generate_head(pulse_location_as_percent_of_display, current_location_on_y_axis_of_display_as_percent_of_display, distance_of_current_location_behind_pulse_as_percent_of_display, distance_of_current_location_in_front_of_pulse_as_percent_of_display, head_offset_as_percent_of_display, pulse);
    bool head_is_defined = define_led_element_at_offset_from_pulse_index(head_offset_in_leds, size_pulse_head_in_leds, size_of_display_in_leds, distance_of_current_location_in_front_of_pulse_as_percent_of_display, distance_of_current_location_behind_pulse_as_percent_of_display);
    float head_factor = -1.0;
    if(head_is_defined){
        head_factor = 1.0;
        if(color_combine_pulse_head_with_fade_in){
            head_factor = (distance_of_current_location_behind_pulse_as_percent_of_display / size_pulse_head_as_percent_of_display) + epsilon_0_to_100;
        }
    }

    
    // Generate decay tail + fade-in
    // Direction controlled by sending either distance_of_current_location_behind_pulse_as_percent_of_display or distance_of_current_location_in_front_of_pulse_as_percent_of_display
    // decay_and_fade_offset.x (decay) and decay_and_fade_offset.y (fade-in) are the distance from pulse index to use as the start of calculations
    float decay_factor =   generate_pulse_decay( distance_of_current_location_behind_pulse_as_percent_of_display, true, pulse_location_as_percent_of_display, size_of_cycle_as_percent_of_display, decay_and_fade_offset.x, pulse);
    float fade_in_factor = generate_pulse_decay( distance_of_current_location_in_front_of_pulse_as_percent_of_display, false, pulse_location_as_percent_of_display, size_of_cycle_as_percent_of_display, decay_and_fade_offset.y, pulse);


    // Keep values in a sensible range: between 0.0 and 1.0
    decay_factor = clamp(decay_factor, 0.0, 1.0);
    fade_in_factor = clamp(fade_in_factor, 0.0, 1.0);
    head_factor = clamp(head_factor, 0.0, 1.0);
    
    //float fade_in_factor = generate_fade_in(current_location_on_y_axis_of_display_as_percent_of_display, pulse_location_as_percent_of_display, size_of_cycle_as_percent_of_display, pulse[index_current_pulse]);
    
    // Call function to generate column output
    //display_output_vector = head_factor * rgb_pulse;
    //display_output_vector = decay_factor * rgb_pulse;
    //display_output_vector = fade_in_factor * rgb_fade_in;
    //display_output_vector = (fade_in_factor + decay_factor) * rgb_pulse;
    //display_output_vector = (fade_in_factor * rgb_fade_in) + (decay_factor * rgb_pulse) + (head_factor * rgb_pulse);

    //display_output_vector = rgb_pulse;
    

    //display_output_vector = (fade_in_factor + head_factor + decay_factor) * rgb_pulse;
    //display_output_vector = (fade_in_factor + decay_factor) * rgb_pulse;

    
    // Display head only if location is +- 1/2 the size of the head from the pulse index
    //if(distance_of_current_location_behind_pulse_as_percent_of_display < (size_pulse_head_as_percent_of_display / 2.0) || distance_of_current_location_in_front_of_pulse_as_percent_of_display < (size_pulse_head_as_percent_of_display / 2.0)){
    
    /*
    if(distance_of_current_location_behind_pulse_as_percent_of_display < (size_pulse_head_as_percent_of_display )){
        display_output_vector = rgb_pulse;
    }
    */
    
    
    
    
    
    
    // Debug section

    ////
    const bool debug_master_rgb = false;
    const bool debug_master_hsluv = true;
    const bool output_as_srgb = true;
    ////

    const bool debug_add_overlay_colorshft = false;

    const bool debug_head = false;
    const bool debug_pulse = false;               
    const bool debug_fade_in = false;  
    const bool debug_background = false;
    const bool debug_decay_and_fade_in = false;
    const bool debug_fade_in_position = false;               // I think it looks better with this set to false
    const bool debug_show_LED_map = false;
    const bool debug_show_distance_behind_pulse = false;
    const bool debug_show_distance_in_front_of_pulse = false;
    const bool debug_define_led_element = false;
    const bool debug_interpolate_hue = false;
    const bool debug_interpolate_hsl = false;

    ////
    const bool debug_show_intended_output = true;
    ////


    if(debug_master_rgb){
        if(debug_add_overlay_colorshft){
            display_output_vector = vec3(sin(iTime), sin(iTime - (pi*two_thirds)), sin(iTime - (2.0*pi*two_thirds)));
        }
        // intended output
        if(debug_show_intended_output){
            // head section
            if(head_factor > 0.0){
                // Apply head
                display_output_vector = restrict_vec3_from_0_to_1((display_output_vector + (head_factor * rgb_pulse)));
            }
            // the rest
            else{
                // Apply fade-in
                display_output_vector = restrict_vec3_from_0_to_1(display_output_vector + (fade_in_factor * rgb_fade_in));
                // Apply decay trail
                display_output_vector = restrict_vec3_from_0_to_1(display_output_vector + (max((decay_factor * rgb_pulse), (color_pulse_minimum_brightness_percent * rgb_pulse))));
                
                float brightness = 0.0;
                // Calculate brightness before, or after applying background
                if(color_brightness_cutoff_includes_background_brightness){
                    display_output_vector = restrict_vec3_from_0_to_1(display_output_vector + rgb_background);
                    brightness = get_brightness_of_color(display_output_vector);
                }
                else{
                    brightness = get_brightness_of_color(display_output_vector);
                    display_output_vector = restrict_vec3_from_0_to_1(display_output_vector + rgb_background);
                }
                
                // Apply alternate color if calculated brightness is below the minimum specified
                if(brightness < color_brightness_cutoff){
                    display_output_vector = rgb_pause;
                }
  
            }
            display_output_vector = restrict_vec3_from_0_to_1(display_output_vector);
        }
        





        if(debug_background){
            display_output_vector += rgb_background;
        }


        if(debug_define_led_element){
            float offset_from_pulse_in_leds = 1.0;
            float size_of_defined_element_in_leds = 1.0;
            bool defined_led_element = define_led_element_at_offset_from_pulse_index(offset_from_pulse_in_leds, size_of_defined_element_in_leds, size_of_display_in_leds, distance_of_current_location_in_front_of_pulse_as_percent_of_display, distance_of_current_location_behind_pulse_as_percent_of_display);
            if(defined_led_element){
                display_output_vector += vec3(0.0, 1.0, 0.0);
            }
            if((distance_of_current_location_behind_pulse_as_percent_of_display < 0.001) || (distance_of_current_location_in_front_of_pulse_as_percent_of_display < 0.001)){
                display_output_vector += vec3(1.0, 0.0, 0.0);
            }
            display_output_vector = restrict_vec3_from_0_to_1(display_output_vector);
        }

        if(debug_show_distance_behind_pulse){
            // Show distance on screen behind pulse location
            // Brighter = Closer
            // Darker = Further away
            display_output_vector += ( 1.0 - (distance_of_current_location_behind_pulse_as_percent_of_display ) ) * rgb_pulse;
            display_output_vector = restrict_vec3_from_0_to_1(display_output_vector);
        }


        if(debug_show_distance_in_front_of_pulse){
            // Show distance on screen behind pulse location
            // Brighter = Closer
            // Darker = Further away
            display_output_vector +=  ( 1.0 - (distance_of_current_location_in_front_of_pulse_as_percent_of_display ) ) * rgb_pulse;
            display_output_vector = restrict_vec3_from_0_to_1(display_output_vector);
        }

        if(debug_show_distance_behind_pulse && debug_show_distance_in_front_of_pulse){
            vec3 backward_output_vector = ( 1.0 - (distance_of_current_location_behind_pulse_as_percent_of_display ) ) * rgb_pulse;
            vec3 forward_output_vector =  ( 1.0 - (distance_of_current_location_in_front_of_pulse_as_percent_of_display ) ) * rgb_pulse;
            backward_output_vector = restrict_vec3_from_0_to_1(backward_output_vector);
            forward_output_vector = restrict_vec3_from_0_to_1(forward_output_vector);
            display_output_vector += (backward_output_vector + forward_output_vector);
            display_output_vector = restrict_vec3_from_0_to_1(display_output_vector);
        }


        if(debug_show_LED_map){
            // Show distance on screen from beginning of the current LED element
            // Brighter = Closer
            // Darker = Further away
            display_output_vector += ( 1.0 - distance_of_current_location_behind_start_of_led_as_percent_of_display * size_of_display_in_leds ) * rgb_pulse;
            display_output_vector = restrict_vec3_from_0_to_1(display_output_vector);
        }



        if(debug_head && debug_pulse && debug_fade_in){
            float decay_border;
            float fade_in_border;
            float decay_or_head_border;

            if(decay_factor == 1.0){
                decay_border = 1.0;
            }
            if(fade_in_factor == 1.0){
                fade_in_border = 1.0;
            }
            if((decay_factor == 1.0) || (fade_in_factor==1.0)){
                decay_or_head_border = 1.0;
            }
            //display_output_vector = (green * head_factor) + (red * ((decay_factor * two_thirds) + (fade_in_factor * one_third)) + (blue * ((decay_factor*one_third) + (fade_in_factor*two_thirds))));
            display_output_vector += (green * head_factor) + (red * (decay_factor + fade_in_factor) + (blue * decay_or_head_border));
            display_output_vector = restrict_vec3_from_0_to_1(display_output_vector);
        }
        else if(debug_head){
            display_output_vector += ones3d * head_factor;
            display_output_vector = restrict_vec3_from_0_to_1(display_output_vector);
        }
        else if(debug_pulse && debug_fade_in){
            //display_output_vector = ones3d * (decay_factor + fade_in_factor);

            float border_fade_in;
            float border_decay;
            float offset_area;
            float pulse_index;
            vec3 debug_vector = vec3(0.0, 0.0, 0.0);
            if(decay_factor == 1.0){
                decay_factor = 0.0;
            }
            if(fade_in_factor == 1.0){
                fade_in_factor = 0.0;
            }

            if(fade_in_factor > 0.99){
                border_fade_in = 1.0;
                fade_in_factor = 0.0;
            }
            if(decay_factor > 0.99){
                border_decay = 1.0;
                decay_factor = 0.0;
            }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
            /*
            // Kind-of working. Doesn't handle overflow.
            if((distance_of_current_location_behind_pulse_as_percent_of_display < decay_and_fade_offset.x ) || (distance_of_current_location_in_front_of_pulse_as_percent_of_display < decay_and_fade_offset.y)){

            if((distance_of_current_location_behind_pulse_as_percent_of_display < decay_and_fade_offset.x ) || (distance_of_current_location_in_front_of_pulse_as_percent_of_display < decay_and_fade_offset.y)){
                offset_area = 1.0;
            }
            */
            // size_pulse_head_as_percent_of_display


            if(close_to(distance_of_current_location_behind_pulse_as_percent_of_display, decay_and_fade_offset.x, 0.01)){
                offset_area = 1.0;
            }
            if(close_to(distance_of_current_location_in_front_of_pulse_as_percent_of_display, decay_and_fade_offset.y, 0.01)){
                offset_area = 1.0;
            }

            /*
            if((distance_of_current_location_in_front_of_pulse_as_percent_of_display < 0.002) || (distance_of_current_location_behind_pulse_as_percent_of_display < 0.002)){
                pulse_index = 1.0;
            }
            */

            if(close_to(distance_of_current_location_in_front_of_pulse_as_percent_of_display, 0.01, 0.01)){
                pulse_index = 1.0;
            }

            display_output_vector += ((border_fade_in * blue) + (border_decay * blue) + ((fade_in_factor + decay_factor) * red) + (offset_area * green) + (pulse_index) ) * ones3d;
            display_output_vector = restrict_vec3_from_0_to_1(display_output_vector);
        }

        else if(debug_fade_in){

            float border_fade_in;
            float offset_area;
            float pulse_index;
            vec3 debug_vector = vec3(0.0, 0.0, 0.0);

            if(fade_in_factor == 1.0){
                fade_in_factor = 0.0;
            }

            if(fade_in_factor > 0.99){
                border_fade_in = 1.0;
                fade_in_factor = 0.0;
            }


            if(close_to(distance_of_current_location_behind_pulse_as_percent_of_display, decay_and_fade_offset.x, 0.01)){
                offset_area = 1.0;
            }
            if(close_to(distance_of_current_location_in_front_of_pulse_as_percent_of_display, decay_and_fade_offset.y, 0.01)){
                offset_area = 1.0;
            }


            if(close_to(distance_of_current_location_in_front_of_pulse_as_percent_of_display, 0.01, 0.01)){
                pulse_index = 1.0;
            }

            display_output_vector += ((border_fade_in * blue) + ((fade_in_factor) * red) + (offset_area * green) + (pulse_index) ) * ones3d;
            display_output_vector = restrict_vec3_from_0_to_1(display_output_vector);
        }

       else if(debug_pulse){

            float border_decay;
            float offset_area;
            float pulse_index;
            vec3 debug_vector = vec3(0.0, 0.0, 0.0);
            if(decay_factor == 1.0){
                decay_factor = 0.0;
            }


            if(decay_factor > 0.99){
                border_decay = 1.0;
                decay_factor = 0.0;
            }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

            if(close_to(distance_of_current_location_behind_pulse_as_percent_of_display, decay_and_fade_offset.x, 0.01)){
                offset_area = 1.0;
            }
            if(close_to(distance_of_current_location_in_front_of_pulse_as_percent_of_display, decay_and_fade_offset.y, 0.01)){
                offset_area = 1.0;
            }


            if(close_to(distance_of_current_location_in_front_of_pulse_as_percent_of_display, 0.01, 0.01)){
                pulse_index = 1.0;
            }

            display_output_vector += ((border_decay * blue) + (decay_factor * red) + (offset_area * green) + (pulse_index) ) * ones3d;
            display_output_vector = restrict_vec3_from_0_to_1(display_output_vector);
        }



    }



    if(debug_master_hsluv){
        float color_pulse_minimum_brightness_value = color_pulse_minimum_brightness_percent * 100.0;
        float display_output_hsl_hue;
        float display_output_hsl_saturation;
        float display_output_hsl_lightness; 
        float hsl_hue_pulse = hsl_pulse[0];
        float hsl_hue_fade_in = hsl_fade_in[0];
        float hsl_hue_background = clamp(hsl_background[0], 0.0, 360.0);
        vec3 display_output_hsl_pulse;
        vec3 display_output_hsl_fade_in;

        // Calculate ratios for blending different colors based on brightness of the color
        float this_location_brightness_decay = (decay_factor*hsl_pulse[2]);
        float this_location_brightness_fade_in = (fade_in_factor*hsl_fade_in[2]);
        float this_location_brightness_background = hsl_background[2];
        float this_location_brightness_total;   // calculated with or without background, later on
        float value_brightness_sum = (this_location_brightness_decay + this_location_brightness_fade_in + this_location_brightness_background);
        float ratio_brightness_head_to_total = ratio_normalized(hsl_pulse[2], value_brightness_sum);
        float ratio_brightness_decay_to_total = ratio_normalized(this_location_brightness_fade_in, value_brightness_sum);
        float ratio_brightness_fade_in_to_total = ratio_normalized(this_location_brightness_fade_in, value_brightness_sum);
        float ratio_brightness_background_to_total = ratio_normalized(this_location_brightness_background, value_brightness_sum);
        float ratio_brightness_background_to_fade_in_and_pulse = ratio_normalized(this_location_brightness_background, (this_location_brightness_decay+this_location_brightness_fade_in));
        float ratio_brightness_background_to_head;    // calculated later on, in head display section
        float ratio_brightness_fade_in_to_pulse = ratio_normalized(this_location_brightness_fade_in, this_location_brightness_decay);




        // Generate fade-in & decay pulse values for the whole column:
        // Hue & saturation as constant from color preset, lightness from preset lightness * decay or fade-in calculation over distance
        display_output_hsl_fade_in = clamp_hsluv(vec3(hsl_fade_in.xy, this_location_brightness_fade_in));
        display_output_hsl_pulse = clamp_hsluv(vec3(hsl_pulse.xy, max(this_location_brightness_decay, color_pulse_minimum_brightness_value)));



        if(debug_show_intended_output){


            // #TO DO# consider redoing this part with interpolate_hsluv instead of interpolate_hue.
            // Calculating ratios is going to be fun


            // Calculate brightness before, or after applying background
            // Needs to be before main section to allow cutoff & alternate color
            if(color_brightness_cutoff_includes_background_brightness){
                // Lightness = max
                this_location_brightness_total = max(max(display_output_hsl_fade_in[2], display_output_hsl_pulse[2]), hsl_background[2]);
            }
            else{
                 // Lightness = max
                this_location_brightness_total = max(display_output_hsl_fade_in[2], display_output_hsl_pulse[2]);
            }

/*
            // Calculate ratios of different element's lightness / brightness
            ratio_brightness_fade_in_to_total = display_output_hsl_fade_in[2] / this_location_brightness_total;
            ratio_brightness_decay_to_total = display_output_hsl_pulse[2] / this_location_brightness_total;
            ratio_brightness_background_to_total = hsl_background[2] / this_location_brightness_total;  // Careful, has the potential to return a value > 1.0  if total brightness is calculated before applying background
            ratio_brightness_fade_in_to_pulse = ratio_normalized(this_location_brightness_fade_in, this_location_brightness_decay);
            ratio_brightness_background_to_fade_in_and_pulse = ratio_normalized(this_location_brightness_background, (this_location_brightness_decay+this_location_brightness_fade_in));
*/

            // Sanity check to clamp ratios to expected levels, shouldn't be needed if everything is working properly
            ratio_brightness_fade_in_to_total = clamp(ratio_brightness_fade_in_to_total, 0.0, 1.0);
            ratio_brightness_decay_to_total = clamp(ratio_brightness_decay_to_total, 0.0, 1.0);
            ratio_brightness_background_to_total = clamp(ratio_brightness_background_to_total, 0.0, 1.0);

            // head section
            if(head_factor > 0.0){
                if(color_combine_pulse_head_with_fade_in){
                    display_output_hsl = interpolate_hsluv(hsl_fade_in, hsl_pulse, head_factor);  
                    //display_output_hsl = hsl_pulse;            
                }
                else{
                    display_output_hsl = hsl_pulse;
                }

                // Combine head with background 
                ratio_brightness_background_to_head = ratio_normalized(this_location_brightness_background, display_output_hsl[2]);
                display_output_hsl = interpolate_hsluv(hsl_background, display_output_hsl, ratio_brightness_background_to_head);    //interpolate total HSLuv
            }
            // non-head section
            else{
                // check if first and last only decay mode is set

                // Case: Not last LED. Disable decay.
                if(fade_and_decay_first_and_last_led_only && (current_location_on_y_axis_of_display_as_percent_of_display < (1.0 - size_of_led_as_percent_of_display) ) ){
                    decay_factor = 0.0;
                }
                // Case: Not first LED. Disable fade-in/
                if(fade_and_decay_first_and_last_led_only && (current_location_on_y_axis_of_display_as_percent_of_display > (size_of_led_as_percent_of_display)) ){
                    fade_in_factor = 0.0;
                }
                
         
                // Generate pulse decay & fade-in. Placement ahead / behind is defined by order of first 2 arguments.
                display_output_hsl_hue = interpolate_hue(hsl_hue_fade_in, hsl_hue_pulse, ratio_brightness_fade_in_to_pulse);    

                // Set lightness & hue. 
                // Consider clean up.
                display_output_hsl_lightness  = max(max((hsl_fade_in[2] * fade_in_factor), (hsl_pulse[2] * decay_factor)), hsl_background[2]);
                //display_output_hsl_saturation = max((hsl_fade_in[1]), (hsl_pulse[1]));  // might want to ratio this
                if(display_output_hsl_lightness==(hsl_fade_in[2] * fade_in_factor)){
                    display_output_hsl_saturation=hsl_fade_in[1];
                }
                else if(display_output_hsl_lightness==(hsl_pulse[2] * decay_factor)){
                    display_output_hsl_saturation=hsl_pulse[1];
                }
                else{
                    display_output_hsl_saturation=hsl_background[1];
                }

                display_output_hsl = vec3(display_output_hsl_hue, display_output_hsl_saturation, display_output_hsl_lightness);    // interpolate hue only, use max saturation & lightness from other fields


                // Blend background into existing output
                //display_output_hsl[0] = interpolate_hue(hsl_hue_background, display_output_hsl_hue, ratio_brightness_background_to_fade_in_and_pulse);    // interpolate hue only
                display_output_hsl = interpolate_hsluv(hsl_background, display_output_hsl, ratio_brightness_background_to_fade_in_and_pulse);    // interpolate entire hsluv

                // Apply alternate color if calculated brightness is below the minimum specified
                if(this_location_brightness_total < (color_brightness_cutoff*100.0)){
                    display_output_hsl = hsl_pause;
                }
            }

            









            // Limit to values actually inside the colorspace
            display_output_hsl = clamp_hsluv(display_output_hsl);

            // optimize chroma by restricting lightness
            if(display_output_hsl[1] > 10.0){
                display_output_hsl[2] = min(display_output_hsl[2], get_max_safe_lightness(display_output_hsl[0]));
            }
        }

        if(debug_head){
            if(head_factor > 0.0){
                if(color_combine_pulse_head_with_fade_in){
                    display_output_hsl = interpolate_hsluv(hsl_fade_in, hsl_pulse, head_factor);                    
                }
                else{
                    display_output_hsl = hsl_pulse;
                }
            }
            //Non-head
            else{
                if(debug_fade_in && !debug_pulse){
                    display_output_hsl = interpolate_hsluv(display_output_hsl_fade_in, display_output_hsl_fade_in, 0.0);
                }
                if(debug_pulse && !debug_fade_in){
                    display_output_hsl = interpolate_hsluv(display_output_hsl_pulse, display_output_hsl_pulse, 0.0);
                }
                if(debug_pulse && debug_fade_in){
                    display_output_hsl_hue = interpolate_hue(display_output_hsl_fade_in[0], display_output_hsl_pulse[0], ratio_brightness_fade_in_to_pulse);  // ratio or interpolation not working yet - seems to be shifting strongly toward black
                    display_output_hsl_lightness = max(this_location_brightness_fade_in, this_location_brightness_decay);
                    display_output_hsl_saturation = max(hsl_fade_in[1], hsl_pulse[1]);
                    display_output_hsl = vec3(display_output_hsl_hue, display_output_hsl_saturation, display_output_hsl_lightness);
                }
            }
        }

        if(debug_background){
            display_output_hsl = hsl_background;
        }


        // Fade in only
        if(debug_fade_in && !debug_pulse && !debug_head){
            //display_output_hsl = interpolate_hsluv(display_output_hsl_fade_in, display_output_hsl_fade_in, 0.0);
            display_output_hsl = display_output_hsl_fade_in;
        }

        // Decay pulse only
        if(debug_pulse && !debug_fade_in && !debug_head){
            display_output_hsl = interpolate_hsluv(display_output_hsl_pulse, display_output_hsl_pulse, 0.0);
        }

        // Fade in + decay pulse
        if(debug_pulse && debug_fade_in && !debug_head){
            display_output_hsl_hue = interpolate_hue(display_output_hsl_fade_in[0], display_output_hsl_pulse[0], ratio_brightness_fade_in_to_pulse);  // ratio_brightness_fade_in_to_pulse is not being set properly for columns 1-3
            //display_output_hsl_hue = interpolate_hue(display_output_hsl_fade_in[0], display_output_hsl_pulse[0], 0.0);
            //display_output_hsl_hue = interpolate_hue(display_output_hsl_fade_in[0], display_output_hsl_pulse[0], 1.0);
            display_output_hsl_lightness = max(this_location_brightness_fade_in, this_location_brightness_decay);
            display_output_hsl_saturation = max(hsl_fade_in[1], hsl_pulse[1]);
            display_output_hsl = vec3(display_output_hsl_hue, display_output_hsl_saturation, display_output_hsl_lightness);
        }

        if(display_output_hsl[1] > 10.0){
            display_output_hsl[2] = min(display_output_hsl[2], get_max_safe_lightness(display_output_hsl[0]));
        }

        if(debug_interpolate_hsl){
        float hue_input_1 = mod(iTime*70.0, 360.0);
        float hue_input_2 = mod((-iTime)*30.0, 360.0);
        float lightness_1 = (50.0 * normalize_trig_function(sin(iTime*0.5))) + 20.0;
        float lightness_2 = (50.0 * normalize_trig_function(sin(iTime*1.1))) + 20.0;
        //float lightness_1 = 100.0 * normalize_trig_function(sin(iTime*0.5));
        //float lightness_2 = 100.0 * normalize_trig_function(sin(iTime*1.1));
        float saturation_1 = 100.0 * normalize_trig_function(sin(iTime*1.3));
        float saturation_2 = 100.0 * normalize_trig_function(sin(iTime*1.7));
        float weight = normalize_trig_function(sin(iTime*0.19));

        //float saturation_1 = 70.0;
        //float saturation_2 = 70.0;
        //float lightness_1 = 70.0;
        //float lightness_2 = 0.0;
        //float weight = 0.5;
        //float saturation_1 = 50.0;
        //float saturation_2 = 0.0;

        vec3 hsl_1 = vec3(hue_input_1, saturation_1, saturation_1);
        vec3 hsl_2 = vec3(hue_input_2, saturation_2, saturation_2);

        vec3 display_output_hsl = interpolate_hsluv(hsl_1, hsl_2, weight);
        display_output_vector = hsluvToRgb(display_output_hsl);
        }

        if(debug_interpolate_hue){
            float hue_input_1 = mod(iTime*70.0, 360.0);
            float hue_input_2 = mod((-iTime)*30.0, 360.0);
            //float hue_input_2 = 270.0;
            float weight = 0.0;
            float lightness = 70.0;
            //float lightness = get_max_safe_lightness(hue);
            //float weight = normalize_trig_function(sin(iTime));


            float hue = interpolate_hue(hue_input_1, hue_input_2, weight);
            vec3 display_output_hsl = vec3(hue, 100, lightness);
            display_output_vector = hsluvToRgb(display_output_hsl);
        }

        display_output_vector = hsluvToRgb(display_output_hsl);
    }




    // Display final output
    if(output_as_srgb){
        display_output_vector = linear_rgb_to_srgb(display_output_vector);
    }
    fragColor = vec4(display_output_vector.x, display_output_vector.y, display_output_vector.z, 1.0);
}


#ifdef GLSLVIEWER
void main() {
    vec4 color;
    iTime = u_time;
    iResolution = u_resolution;
    mainImage(color, gl_FragCoord.xy);
    FragColor = color;
}
#endif
